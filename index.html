<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>随风</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="屌丝程序员的自留地#为搜索引擎留的">
<meta property="og:type" content="website">
<meta property="og:title" content="随风">
<meta property="og:url" content="http://shitaibin.github.io/index.html">
<meta property="og:site_name" content="随风">
<meta property="og:description" content="屌丝程序员的自留地#为搜索引擎留的">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="随风">
<meta name="twitter:description" content="屌丝程序员的自留地#为搜索引擎留的">
  
    <link rel="alternative" href="/atom.xml" title="随风" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xixtr.com1.z0.glb.clouddn.com/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">随风</a></h1>
		</hgroup>

		
		<p class="header-subtitle">随风而起，随风而散</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shitaibin" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Github-Pages/" style="font-size: 10px;">Github Pages</a> <a href="/tags/Hexo/" style="font-size: 20px;">Hexo</a> <a href="/tags/Package/" style="font-size: 13.33px;">Package</a> <a href="/tags/Python/" style="font-size: 16.67px;">Python</a> <a href="/tags/Python试错/" style="font-size: 10px;">Python试错</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/TADM/" style="font-size: 13.33px;">TADM</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/单元测试/" style="font-size: 16.67px;">单元测试</a> <a href="/tags/图论/" style="font-size: 10px;">图论</a> <a href="/tags/待办/" style="font-size: 10px;">待办</a> <a href="/tags/思考/" style="font-size: 16.67px;">思考</a> <a href="/tags/招聘/" style="font-size: 10px;">招聘</a> <a href="/tags/排序/" style="font-size: 10px;">排序</a> <a href="/tags/搜索/" style="font-size: 13.33px;">搜索</a> <a href="/tags/数据挖掘/" style="font-size: 10px;">数据挖掘</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/特征/" style="font-size: 10px;">特征</a> <a href="/tags/编程语言/" style="font-size: 10px;">编程语言</a> <a href="/tags/翻译/" style="font-size: 10px;">翻译</a> <a href="/tags/面试/" style="font-size: 13.33px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">随风</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xixtr.com1.z0.glb.clouddn.com/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">随风</h1>
			</hgroup>
			
			<p class="header-subtitle">随风而起，随风而散</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shitaibin" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-feature-engineering" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/17/feature-engineering/" class="article-date">
  	<time datetime="2016-03-17T00:49:06.000Z" itemprop="datePublished">2016-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/17/feature-engineering/">特征工程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>特征决定了机器学习的上限，而算法只不过是在逼近这个上限而已。</p>
</blockquote>
<p>足见特征的重要性，以房子举个栗子：特征是机器学习的地基，而算法是在地基上的房子，地基不稳，也不会得到健壮的房子。</p>
<p>在机器学习和数据挖掘的书籍中都会提到特征工程，他们阐述了特征工程的类别，主要为特征提取和特征选择，并说明了他们的作用，但是好像也都没有详细的讲述如何做特征工程，其实原因也很简单，那些书籍重在讲述算法，所以他们尽量选择合适/简单的数据和特征，以便能讲清楚算法原理，所以，当你按照书上的那些例子跑实验，自然也能得到理想的结果，潜移默化的让你认为算法比特征工程重要，因为，你从来没有做过特征工程。</p>
<p>此文，拟打算探索一下特征工程，后续在动手撸实验，求是一下。</p>
<p>这是一个特征工程的思维导图：<a href="http://www.processon.com/view/link/5577f378e4b0d6a77d9c400c" target="_blank" rel="external">时光机</a>。</p>
<p>机器学习被成为你一门艺术，一门黑艺术。</p>
<p>实践出真知。</p>
<h1 id="参考资料">参考资料</h1><ul>
<li>博客-极力推荐-许多文章都参考了这篇文章-另外可以关注该博主的邮件列表：<a href="http://machinelearningmastery.com/discover-feature-engineering-how-to-engineer-features-and-how-to-get-good-at-it/" target="_blank" rel="external">http://machinelearningmastery.com/discover-feature-engineering-how-to-engineer-features-and-how-to-get-good-at-it/</a></li>
<li>知乎-特征工程：<a href="https://www.zhihu.com/question/29316149" target="_blank" rel="external">https://www.zhihu.com/question/29316149</a></li>
<li>知乎-特征选择：<a href="https://www.zhihu.com/question/28641663/answer/41653367" target="_blank" rel="external">https://www.zhihu.com/question/28641663/answer/41653367</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据挖掘/">数据挖掘</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/特征/">特征</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-review-SQL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/13/review-SQL/" class="article-date">
  	<time datetime="2016-03-13T06:47:20.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/review-SQL/">SQL回顾总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本博文中的所有内容，可以在MySQL 5.6.21中运行。</p>
</blockquote>
<p>MySQL 5.1在线参考手册：<a href="http://doc.mysql.cn/mysql5/refman-5.1-zh.html-chapter/" target="_blank" rel="external">时光机</a></p>
<h1 id="查询">查询</h1><h2 id="限制行号和偏倚量。">限制行号和偏倚量。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>,<span class="number">3</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="注释">注释</h2><p>1) 嵌入在行内<br>2) 整行都是注释<br>3) 块注释</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="comment">--</span></span><br><span class="line">2) #</span><br><span class="line">3) <span class="comment">/*  */</span></span><br></pre></td></tr></table></figure>
<h1 id="检索排序">检索排序</h1><blockquote>
<p>关键字：ORDER BY，DESC。</p>
</blockquote>
<h2 id="ORDER_BY子句的位置（必须最后一句）">ORDER BY子句的位置（必须最后一句）</h2><p>  在指定一条ORDER BY子句时，应该保证它是SELECT语句中最后一条子句。如果它不是最后的子句，将会出现错误消息。</p>
<h2 id="通过非选择列进行排序（排序的那列可以不显示）">通过非选择列进行排序（排序的那列可以不显示）</h2><p>  通常，ORDER BY子句中使用的列将是为显示而选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。</p>
<h2 id="多列排序">多列排序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price, prod_name;</span></span><br></pre></td></tr></table></figure>
<p>效果<br><img src="http://7xixtr.com1.z0.glb.clouddn.com/review-SQL-3-1.png" alt=""></p>
<p>为什么列顺序不是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price, prod_name;</span></span><br></pre></td></tr></table></figure>
<p>效果<br><img src="http://7xixtr.com1.z0.glb.clouddn.com/review-SQL-3-2.png" alt=""></p>
<p>因为<code>prod_name</code>放中间不好看。</p>
<h2 id="按列位置排序">按列位置排序</h2><p><strong>禁止使用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span>, <span class="number">3</span>;</span></span><br></pre></td></tr></table></figure>
<p>虽然简写了列名字，但容易出错，并且相当不直观，隐藏了潜在BUG。在修改SQL的语句的更容易错误，可能依据的排序列根本不在查询中。</p>
<h2 id="逆序">逆序</h2><p>在排序依据列的名字加DESC。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name <span class="keyword">DESC</span>;</span></span><br></pre></td></tr></table></figure>
<p>效果：根据价格从高到低排序，同价，则根据名字，从后向前排序。</p>
<h1 id="检索过滤">检索过滤</h1><blockquote>
<p>关键词：WHERE。</p>
</blockquote>
<h2 id="操作符">操作符</h2><p><img src="http://7xixtr.com1.z0.glb.clouddn.com/review-SQL-operators.png" alt=""></p>
<h2 id="范围检查">范围检查</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">8</span> <span class="keyword">AND</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="空值检查">空值检查</h2><p>IS NULL。</p>
<p><strong>这不同于值为0，或字符串为空。</strong></p>
<p>查找没有邮箱的客户。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cust_name</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="literal">NULL</span>;</span></span><br></pre></td></tr></table></figure>
<p>找到有邮箱的用户。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cust_name</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span></span><br></pre></td></tr></table></figure>
<h1 id="高级过滤">高级过滤</h1><blockquote>
<p>关键词：NOT，IN，AND，OR。</p>
</blockquote>
<h2 id="AND,_OR">AND, OR</h2><p>WHERE子句可以包含任意数目的AND和OR操作符。允许两者结合以进行复杂、高级的过滤。SQL（像多数语言一样）<strong>在处理OR操作符前，优先处理AND操作符</strong>。当SQL看到上述WHERE子句时，它理解为：由供应商BRS01制造的价格为10美元以上的所有产品，以及由供应商DLL01制造的所有产品，而不管其价格如何。换句话说，由于AND在求值过程中优先级更高，操作符被错误地组合了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="string">'DLL01'</span> <span class="keyword">OR</span> vend_id = ‘BRS01’</span><br><span class="line"><span class="keyword">AND</span> prod_price &gt;= <span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>理想是这样子的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> (vend_id = <span class="string">'DLL01'</span> <span class="keyword">OR</span> vend_id = ‘BRS01’)</span><br><span class="line"><span class="keyword">AND</span> prod_price &gt;= <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="IN">IN</h2><p>满足所在集合的记录。</p>
<ol>
<li><strong>完成的是OR的工作，IN是OR的简洁版本</strong>。</li>
<li>在有很多合法选项时，IN操作符的语法<strong>更清楚，更直观</strong>。</li>
<li>在与其他AND和OR操作符组合使用IN时，求值顺序更<strong>容易管理</strong>。</li>
<li>IN操作符一般比一组OR操作符执行得<strong>更快</strong>。</li>
<li>IN的最大优点是可以<strong>包含其他SELECT语句，能够更动态地建立WHERE子句</strong>。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id</span><br><span class="line"><span class="keyword">IN</span> (<span class="string">'DLL01'</span>, <span class="string">'BRS01'</span>);</span></span><br></pre></td></tr></table></figure>
<h2 id="NOT">NOT</h2><p>WHERE子句中的NOT操作符有且只有一个功能，那就是否定<strong>其后</strong>所跟的任何条件。<br>在更复杂的子句中，NOT是非常有用的。例如，在与IN操作符联合使用时，NOT可以非常简单地找出与条件列表不匹配的行。</p>
<h1 id="通配符过滤">通配符过滤</h1><blockquote>
<p>关键词：%，_。</p>
</blockquote>
<p>引用自《SQL必知必会》。</p>
<blockquote>
<p>通配符（wildcard）<br>用来匹配值的一部分的特殊字符。</p>
<p>搜索模式（search pattern）<br>由字面值、通配符或两者组合构成的搜索条件。</p>
</blockquote>
<p>通配符本身实际上是SQL的WHERE子句中有特殊含义的字符，SQL支持几种通配符。为在搜索子句中使用通配符，必须使用LIKE操作符。LIKE指示DBMS，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。</p>
<blockquote>
<p>谓词（predicate）<br>操作符何时不是操作符？答案是，它作为谓词时。从技术上说，LIKE是谓词而不是操作符。虽然最终的结果是相同的，但应该对此术语有所了解，以免在SQL文献或手册中遇到此术语时不知所云。</p>
</blockquote>
<h2 id="谓词：LIKE">谓词：<code>LIKE</code></h2><h2 id="%：任何字符出现任意次数">%：任何字符出现任意次数</h2><ol>
<li>使用相当的灵活，可以把<code>%</code>放在字符串的任何一个位置，也可以使用多个<code>%</code>。</li>
<li>不匹配<code>NULL</code>。</li>
</ol>
<p>搜索商品名称以Fish开头的商品。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'Fish%'</span>;</span></span><br></pre></td></tr></table></figure>
<p>以bag结尾呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE prod_name LIKE '%bag';</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'F%y' ： 以F开头，以y结尾。</span><br><span class="line">'F%y%'：以F开头，中间有y。</span><br></pre></td></tr></table></figure>
<p>实用案例：邮箱匹配</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_name, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">LIKE</span> <span class="string">'%@fun4all.com'</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="_：只匹配单个字符。">_：只匹配单个字符。</h2><ol>
<li>有且仅有一个字符。</li>
<li>可以是空格。</li>
<li>可以连用。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'__ inch teddy bear'</span>;</span></span><br></pre></td></tr></table></figure>
<p><strong>MySQL的LIKE只支持<code>%</code>和<code>_</code>，其他匹配，可以使用谓词<code>REGEXP</code>。</strong></p>
<h2 id="技巧">技巧</h2><ol>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>
</ol>
<h1 id="计算字段">计算字段</h1><blockquote>
<p>字段（field）<br>基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常与计算字段一起使用。</p>
</blockquote>
<h2 id="拼接">拼接</h2><p>MySQL需要使用拼接函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">concat(): 参数为列名，和字符串</span><br><span class="line">concat_ws(): 第一个参数为连接符，剩余参数为列明，各列之间使用连接符连接</span><br></pre></td></tr></table></figure>
<p>例1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(vend_name, <span class="string">'('</span>, vend_country, <span class="string">')'</span>)</span><br><span class="line">	<span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors;</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">'Bear Emporium(USA)'</span><br><span class="line">'Bears R Us(USA)'</span><br><span class="line">'Doll House Inc.(USA)'</span><br><span class="line">'Fun and Games(England)'</span><br><span class="line">'Furball Inc.(USA)'</span><br><span class="line">'Jouets et ours(France)'</span><br></pre></td></tr></table></figure>
<p>例2</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">concat_ws</span>(<span class="string">'-'</span>, vend_name, vend_country)</span><br><span class="line"><span class="keyword">FROM</span> vendors;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">'Bear Emporium-USA'</span><br><span class="line">'Bears R Us-USA'</span><br><span class="line">'Doll House Inc.-USA'</span><br><span class="line">'Fun and Games-England'</span><br><span class="line">'Furball Inc.-USA'</span><br><span class="line">'Jouets et ours-France'</span><br></pre></td></tr></table></figure>
<h2 id="别名/导出列">别名/导出列</h2><p>AS是SQL的一条最佳实践。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">concat_ws</span>(<span class="string">'-'</span>, vend_name, vend_country)</span><br><span class="line">	<span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors;</span></span><br></pre></td></tr></table></figure>
<h2 id="算术计算">算术计算</h2><p>支持列或字段之间的四则运算。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">	   quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20008</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>SELECT语句校验<br>SELECT语句为测试、检验函数和计算提供了很好的方法。虽然SELECT通常用于从表中检索数据，但是省略了FROM子句后就是简单地访问和处理表达式，例如SELECT 3 * 2;将返回6，SELECT Trim(‘ abc ‘);将返回abc，SELECT Now();使用Now()函数返回当前日期和时间。现在你明白了，可以根据需要使用SELECT语句进行检验。</p>
</blockquote>
<h1 id="函数">函数</h1><blockquote>
<p>不同的DBMS支持的函数不同。</p>
</blockquote>
<p>常用函数可以分为以下几类：</p>
<ul>
<li>数值函数</li>
<li>文本函数</li>
<li>日期时间函数</li>
<li>DBMS系统函数</li>
</ul>
<p>常用函数参考：<a href="http://www.cnblogs.com/kissdodog/p/4168721.html" target="_blank" rel="external">时光机</a></p>
<h2 id="文本函数">文本函数</h2><p>处理字符串的函数。</p>
<p>例1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> vend_name,</span><br><span class="line">  <span class="keyword">upper</span>(vend_name) <span class="keyword">AS</span> vend_name_upcase</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span></span><br></pre></td></tr></table></figure>
<h2 id="日期时间函数">日期时间函数</h2><p>日期和时间采用相应的数据类型存储在表中，<strong>每种DBMS都有自己的特殊形式</strong>。日期和时间值以特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。</p>
<p>应用程序一般不使用日期和时间的存储格式，因此日期和时间函数总是用来读取、统计和处理这些值。由于这个原因，日期和时间函数在SQL中具有重要的作用。遗憾的是，它们很不一致，<strong>可移植性最差</strong>。</p>
<p><strong>时间函数相当的丰富，包含了各种转换，日期加减，抽取。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">curdate</span>();</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">curtime</span>();</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">now</span>();</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">month</span>(<span class="string">"2016-3-13 1:1:1"</span>);</span> <span class="comment">-- 获取输入date的月份</span></span><br></pre></td></tr></table></figure>
<h2 id="数值处理">数值处理</h2><p><strong>在各大DBMS中，最统一、最一致的函数。</strong></p>
<p>主要包括代数、三角、几何运算。</p>
<h1 id="聚集函数">聚集函数</h1><p>聚集函数（aggregate function）对某些行运行的函数，计算并返回一个值。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/9-1.png" alt=""></p>
<h2 id="AVG">AVG</h2><ul>
<li>AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。</li>
<li>忽略NULL行。</li>
</ul>
<h2 id="COUNT">COUNT</h2><ul>
<li>返回指定列所有非NULL行数。</li>
</ul>
<h2 id="MAX、MIN">MAX、MIN</h2><ul>
<li>返回指定列所有非NULL行的最大/小值。</li>
</ul>
<h2 id="SUM">SUM</h2><ul>
<li>返回指定列的总和。</li>
<li>忽略NULL行。</li>
</ul>
<h2 id="函数参数">函数参数</h2><p>以上4个函数：可以是数值列运算后的得到的新字段，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(item_price*quantity) <span class="keyword">AS</span> total_price</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20005</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="结合DISTINCT">结合DISTINCT</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="string">'DLL01'</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="奇葩的存在">奇葩的存在</h2><p>唯有COUNT可以使用*。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_items</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="string">'DLL01'</span>;</span></span><br></pre></td></tr></table></figure>
<h1 id="分组数据">分组数据</h1><blockquote>
<p>关键词：GROUP BY &amp; HAVING。</p>
</blockquote>
<h2 id="GROUP_BY">GROUP BY</h2><ul>
<li>GROUP BY子句可以包含任意数目的列，因而可以对分组进行<strong>嵌套</strong>，更细致地进行数据分组。</li>
<li>如果在GROUP  BY子句中嵌套了分组，数据将在<strong>最后指定的分组</strong>上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li>GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP  BY子句中指定相同的表达式。不能使用别名。</li>
<li>大多数SQL实现不允许GROUP BY列带有长度可变的数据类型（如文本或备注型字段）。</li>
<li>除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出。【并没有呀，下例依然可以运行，<strong>但是结果并不是想要的</strong>】</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> vend_id, prod_id, <span class="keyword">COUNT</span>(*) <span class="keyword">as</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span></span><br></pre></td></tr></table></figure>
<p>这样只会去那个<code>vend_id</code>的第一个<code>prod_id</code>。</p>
<p>所以还是需要遵循规则：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> vend_id, prod_id, <span class="keyword">COUNT</span>(*) <span class="keyword">as</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id, prod_id;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li>
<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</li>
</ul>
<h2 id="过滤分组：HAVING">过滤分组：HAVING</h2><ul>
<li>WHERE是针对行的，不是针对分组。</li>
<li>HAVING支持所有WHERE操作符。</li>
<li>唯一差别：WHERE过滤行，而HAVING过滤分组。</li>
</ul>
<ul>
<li>MySQL允许HAVING中使用列/字段的别名。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL允许HAVING中使用列/字段的别名</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> orders &gt;= <span class="number">2</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。</li>
<li>同时是使用WHERE, HAVING。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 选择价格大于4并且至少有2个商品的供应商。</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">as</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &gt;= <span class="number">4</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">HAVING</span> num_prods &gt;= <span class="number">2</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>GROUP不保证输出数据有序。要有序，需要结合ORDER BY。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 选择订购买商品数量大于3的订单，并且按商品数量和订单号排序。</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> order_num, <span class="keyword">COUNT</span>(*) <span class="keyword">as</span> items</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> order_num</span><br><span class="line"><span class="keyword">HAVING</span> items &gt;= <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> items, order_num;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/10-2.png" alt=""></p>
<h1 id="子查询">子查询</h1><blockquote>
<p>MySQL从4.1版本才支持子查询。</p>
</blockquote>
<ul>
<li>子查询总是从内向外处理。</li>
<li>包含子查询的SELECT语句难以阅读和调试，它们在较为复杂时更是如此。如上所示，把子查询分解为多行并进行适当的缩进，能极大地简化子查询的使用。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找购买了RGAN01的用户的信息。</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line"> <span class="keyword">FROM</span> Orders</span><br><span class="line"> <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line"> <span class="keyword">FROM</span> orderitems</span><br><span class="line"> <span class="keyword">WHERE</span> prod_id = <span class="string">'RGAN01'</span>));</span></span><br></pre></td></tr></table></figure>
<ul>
<li>警告：只能是单列<br>  作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误。</li>
<li>警告：子查询和性能<br>  这里给出的代码有效，并且获得了所需的结果。但是，使用子查询并不总是执行这类数据检索的最有效方法。更多的论述，请参阅第12课，其中将再次给出这个例子。</li>
</ul>
<h2 id="作为计算字段使用子查询">作为计算字段使用子查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_name, </span><br><span class="line">       cust_state,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) </span><br><span class="line">        <span class="keyword">FROM</span> Orders </span><br><span class="line">        <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> Customers </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span></span><br></pre></td></tr></table></figure>
<h1 id="联结表">联结表</h1><blockquote>
<p>关键词：JOIN。</p>
<p>联结： 如果数据存储在多个表中，怎样用一条SELECT语句就检索出数据呢？</p>
</blockquote>
<h2 id="联结">联结</h2><ul>
<li>关系通过主键而建立。</li>
<li>SQL语句中可以省略JOIN关键词。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors, products</span><br><span class="line"><span class="keyword">WHERE</span> vendors.vend_id = products.vend_id;</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price&#10;FROM vendors JOIN products&#10;WHERE vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/12-1.png" alt=""></p>
<ul>
<li>如果没有WHERE，将会产生笛卡尔积效果：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors, products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/12-2.png" alt=""></p>
<p>所以我们需要WHERE进行过滤。</p>
<h2 id="内连接">内连接</h2><p>目前使用的联结又称为等值联结，也被称为内联结，换另外一种方式：</p>
<p>使用关键词<code>INNER JOIN</code>和<code>ON</code>，省略掉了<code>WHERE</code>效果相同。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id = products.vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span></span><br></pre></td></tr></table></figure>
<h2 id="联结多个表">联结多个表</h2><p>SQL不限制一条SELECT语句中可以联结的表的数目，但联结越多，性能下降越大。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 20007这个订单下的所有商品，价格及数量，以及供货商。</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_name, vend_name, prod_price, quantity</span><br><span class="line"><span class="keyword">FROM</span> vendors, products, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> vendors.vend_id = products.vend_id</span><br><span class="line">  <span class="keyword">AND</span> orderitems.prod_id = products.prod_id</span><br><span class="line">  <span class="keyword">AND</span> orderitems.order_num = <span class="number">20007</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span></span><br></pre></td></tr></table></figure>
<p>以简洁的JOIN完成上一节SELECT的子查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id</span><br><span class="line">  <span class="keyword">AND</span> orderitems.order_num = orders.order_num</span><br><span class="line">  <span class="keyword">AND</span> orderitems.prod_id = <span class="string">'RGAN01'</span></span></span><br></pre></td></tr></table></figure>
<h1 id="高级联结">高级联结</h1><blockquote>
<p>关键词：别名、外联结、聚集函数。</p>
</blockquote>
<h2 id="别名">别名</h2><ul>
<li>缩短SQL语句；</li>
<li>允许在一条SELECT语句中多次使用相同的表。</li>
<li>与列别名不一样，表别名不返回到客户端。</li>
<li>MySQL里面支持省略<code>AS</code>，就像Oracle的一样，Oracle是不支持使用<code>AS</code>。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> <span class="keyword">C</span>, orders <span class="keyword">AS</span> O, orderitems <span class="keyword">AS</span> OI</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">C</span>.cust_id = O.cust_id</span><br><span class="line">  <span class="keyword">AND</span> O.order_num = OI.order_num</span><br><span class="line">  <span class="keyword">AND</span> OI.prod_id = <span class="string">'RGAN01'</span>;</span></span><br></pre></td></tr></table></figure>
<p>WHERE语句中的条件顺序很重要，一般可以是这种思路：我查询的是customer信息，那么第一个条件先写和customer相关的，就会引出另外一张表，再写和这张表相关的，最后一个条件，必然为限定条件。</p>
<h2 id="不同类型的联结">不同类型的联结</h2><p>四种其他联结：内连接（inner join）、自联结（self-join）、自然联结（natural join）和外联结（outer join）。</p>
<h3 id="自联结">自联结</h3><p>条件与所查询的内容在同一个表。</p>
<p>假如要给与Jim Jones同一公司的所有顾客发送一封信件。这个查询要求首先找出Jim Jones工作的公司，然后找出在该公司工作的顾客。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/13-1.png" alt=""></p>
<p>在这里好像cust_name是公司名，而cust_contact是联系人的名字，而Jim Jones则是其中的一个联系人。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> c1.cust_id, c1.cust_name, c1.cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c1, Customers <span class="keyword">AS</span> c2</span><br><span class="line"><span class="keyword">WHERE</span> c1.cust_name = c2.cust_name</span><br><span class="line">  <span class="keyword">AND</span> c2.cust_contact = <span class="string">'Jim Jones'</span>;</span></span><br></pre></td></tr></table></figure>
<h3 id="自然联结">自然联结</h3><p>自然联结排除多次出现，使每一列只返回一次。事实上，我们迄今为止建立的每个内联结都是自然联结，很可能永远都不会用到不是自然联结的内联结。</p>
<h3 id="外联结">外联结</h3><p>不仅包含，有关联行的那些行，还包含没有关联行的那些行。</p>
<ul>
<li>LEFT：包含左边表的所有行。</li>
<li>RIGHT：包含右边表的所有行。</li>
<li>是需要调整FROM语句中的表的顺序，就可以互换LEFT和RIGHT。</li>
<li>MySQL不支持<code>FULL OUTER JOIN</code>。</li>
<li>条件只能使用<code>ON</code>过滤。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> orders <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> customers</span><br><span class="line"><span class="keyword">ON</span> orders.cust_id = customers.cust_id;</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/13-2.png" alt=""></p>
<h2 id="聚集函数与联结">聚集函数与联结</h2><p>联结不过是把不同表中的数据合到一张“虚拟的表”，这张虚拟的表，就是由选择的列构成，我们可以在这些列上，使用聚合函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询有订单的每个用户的订单数量</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> customers.cust_id, </span><br><span class="line">	<span class="keyword">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> customers, orders</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 简化上一个SQL查询</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> customers.cust_id <span class="keyword">AS</span> customer_id,</span><br><span class="line">	<span class="keyword">COUNT</span>(orders.order_num) <span class="keyword">AS</span> order_count</span><br><span class="line"><span class="keyword">FROM</span> customers, orders</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span></span><br></pre></td></tr></table></figure>
<p>查询每个用户的订单数量，包含哪些没有订单的用户。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> customers.cust_id <span class="keyword">AS</span> customer_id,</span><br><span class="line">  <span class="keyword">COUNT</span>(orders.order_num) <span class="keyword">AS</span> order_count</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span></span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="http://7xixtr.com1.z0.glb.clouddn.com/13-3.png" alt=""></p>
<h2 id="联结总结">联结总结</h2><ol>
<li>注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效。</li>
<li>关于确切的联结语法，应该查看具体的文档，看相应的DBMS支持何种语法（大多数DBMS使用这两课中描述的某种语法）。</li>
<li>保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确的数据。</li>
<li>应该总是提供联结条件，否则会得出笛卡儿积。</li>
<li>在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前分别测试每个联结。这会使故障排除更为简单。</li>
</ol>
<h1 id="组合查询">组合查询</h1><blockquote>
<p>关键词：UNION。</p>
</blockquote>
<p>执行多个查询（多条SELECT语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。</p>
<ul>
<li>每个查询之间，使用一个<code>UNION</code>。</li>
<li><code>UNION</code>会去掉各查询结果重复的项，仅保留一个。</li>
<li><code>UNION ALL</code>可以保留重复的项。</li>
</ul>
<p>主要有两种情况需要使用组合查询：</p>
<ol>
<li>在一个查询中从不同的表返回结构数据；</li>
<li>对一个表执行多个查询，按一个查询返回数据。</li>
</ol>
<h2 id="同WHERE转换">同WHERE转换</h2><p><strong>组合相同表</strong>的两个查询所完成的工作与具有多个WHERE子句条件的一个查询所完成的工作相同，使用<code>OR</code>组合过滤条件即可。换句话说，任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询，在下面可以看到这一点。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 同一表中查询</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">in</span> (<span class="string">'IL'</span>, <span class="string">'IN'</span>, <span class="string">'MI'</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name = <span class="string">'Fun4ALL'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 替换为等价的WHERE过滤</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">in</span> (<span class="string">'IL'</span>, <span class="string">'IN'</span>, <span class="string">'MI'</span>)</span><br><span class="line">   <span class="keyword">OR</span> cust_name = <span class="string">'Fun4ALL'</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="排序">排序</h2><p>放在最后一行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">in</span> (<span class="string">'IL'</span>, <span class="string">'IN'</span>, <span class="string">'MI'</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name = <span class="string">'Fun4ALL'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name, cust_contact;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>以上全是查询，下面的内容开启，修改数据库内容。</p>
<h1 id="插入数据">插入数据</h1><blockquote>
<p>关键词：INSERT、INTO、VALUES。</p>
</blockquote>
<p>插入有以下三种功能：</p>
<ul>
<li>插入完整的行；</li>
<li>插入行的一部分；</li>
<li>插入某些查询的结果。</li>
</ul>
<h2 id="插入完整的一行">插入完整的一行</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'1000000006'</span>,</span><br><span class="line">        <span class="string">'Toy Land'</span>,</span><br><span class="line">        <span class="string">'123 Any Street'</span>,</span><br><span class="line">        <span class="string">'New York'</span>,</span><br><span class="line">        <span class="string">'NY'</span>,</span><br><span class="line">        <span class="string">'11111'</span>,</span><br><span class="line">        <span class="string">'USA'</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>);</span></span><br></pre></td></tr></table></figure>
<p>不安全，依赖于表中列的次序，更安全的方案是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id,</span><br><span class="line">                      cust_name,</span><br><span class="line">                      cust_address,</span><br><span class="line">                      cust_city,</span><br><span class="line">                      cust_state,</span><br><span class="line">                      cust_zip,</span><br><span class="line">                      cust_country,</span><br><span class="line">                      cust_contact,</span><br><span class="line">                      cust_email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'1000000006'</span>,</span><br><span class="line">       <span class="string">'Toy Land'</span>,</span><br><span class="line">       <span class="string">'123 Any Street'</span>,</span><br><span class="line">       <span class="string">'New York'</span>,</span><br><span class="line">       <span class="string">'NY'</span>,</span><br><span class="line">       <span class="string">'11111'</span>,</span><br><span class="line">       <span class="string">'USA'</span>,</span><br><span class="line">       <span class="literal">NULL</span>,</span><br><span class="line">       <span class="literal">NULL</span>);</span></span><br></pre></td></tr></table></figure>
<h2 id="插入部分行">插入部分行</h2><p>插入哪些列，就使用那些列的名字。</p>
<p>前提是：省略的那些列，</p>
<ul>
<li>允许NULL，</li>
<li>或者提供了默认值，<br>不然会出错。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id,</span><br><span class="line">                      cust_name,</span><br><span class="line">                      cust_address,</span><br><span class="line">                      cust_city,</span><br><span class="line">                      cust_state,</span><br><span class="line">                      cust_zip,</span><br><span class="line">                      cust_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'1000000008'</span>,</span><br><span class="line">       <span class="string">'Toy Land'</span>,</span><br><span class="line">       <span class="string">'123 Any Street'</span>,</span><br><span class="line">       <span class="string">'New York'</span>,</span><br><span class="line">       <span class="string">'NY'</span>,</span><br><span class="line">       <span class="string">'11111'</span>,</span><br><span class="line">       <span class="string">'USA'</span>);</span></span><br></pre></td></tr></table></figure>
<h2 id="插入SELECT结果">插入SELECT结果</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将数据从custnew取出，插入到customers</span></span><br><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id,</span><br><span class="line">                      cust_contact,</span><br><span class="line">                      cust_email,</span><br><span class="line">                      cust_name,</span><br><span class="line">                      cust_address,</span><br><span class="line">                      cust_city,</span><br><span class="line">                      cust_state,</span><br><span class="line">                      cust_zip,</span><br><span class="line">                      cust_country)</span><br><span class="line"><span class="keyword">SELECT</span> cust_id,</span><br><span class="line">       cust_contact,</span><br><span class="line">       cust_email,</span><br><span class="line">       cust_name,</span><br><span class="line">       cust_address,</span><br><span class="line">       cust_city,</span><br><span class="line">       cust_state,</span><br><span class="line">       cust_zip,</span><br><span class="line">       cust_country</span><br><span class="line"><span class="keyword">FROM</span> CustNew;</span></span><br></pre></td></tr></table></figure>
<h2 id="插入多行">插入多行</h2><p>使用多个INSERT语句。</p>
<h2 id="从一个表复制到另外一个表">从一个表复制到另外一个表</h2><ul>
<li>要创建一个全新的表。</li>
<li>如果只复制部分列，修改SELECT语句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE custcopy AS&#10;SELECT * FROM customers;</span><br></pre></td></tr></table></figure>
<h1 id="更新和删除数据(表内容)">更新和删除数据(表内容)</h1><blockquote>
<p>关键词： UPDATE、DELETE、SET。</p>
</blockquote>
<h2 id="UPDATE">UPDATE</h2><p>两个功能：</p>
<ul>
<li>修改表中特定的行。</li>
<li>修改所有的行。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新一个列</span></span><br><span class="line"><span class="operator"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> cust_email = <span class="string">'kim@thetoystore.com'</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="string">'1000000005'</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要省略WHERE子句，不然就更新所有行了。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新多个列，只需要1个SET</span></span><br><span class="line"><span class="operator"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> cust_contact = <span class="string">'Sam Roberts'</span>,</span><br><span class="line">    cust_email = <span class="string">'sam@toyland.com'</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="string">'1000000006'</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="DELETE">DELETE</h2><p>两个功能：</p>
<ul>
<li>删除表中特定的行。</li>
<li>删除所有的行。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id = <span class="string">'100000006'</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>更快的清空表</li>
</ul>
<p>它比使用DELETE清空表更快，因为它不记录数据的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE custcopy;</span><br></pre></td></tr></table></figure>
<h2 id="UPDATE和DELETE重要原则">UPDATE和DELETE重要原则</h2><ol>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。</li>
<li>保证每个表都有主键（如果忘记这个内容，请参阅第12课），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。</li>
<li>在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。</li>
<li>使用强制实施引用完整性的数据库（关于这个内容，请参阅第12课），这样DBMS将不允许删除其数据与其他表相关联的行。</li>
<li>有的DBMS允许数据库管理员施加约束，防止执行不带WHERE子句的UPDATE或DELETE语句。如果所采用的DBMS支持这个特性，应该使用它。</li>
</ol>
<h1 id="创建和操纵表">创建和操纵表</h1><blockquote>
<p>关键词：CREATE TABLE。</p>
</blockquote>
<h2 id="创建表">创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copyproducts</span><br><span class="line">(</span><br><span class="line">    prod_id       <span class="built_in">CHAR</span>(<span class="number">10</span>)          <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    vend_id       <span class="built_in">CHAR</span>(<span class="number">10</span>)          <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    prod_name     <span class="built_in">CHAR</span>(<span class="number">254</span>)         <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    prod_price    <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    prod_desc     <span class="built_in">text</span>              <span class="literal">NULL</span></span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<p>表名紧跟CREATE TABLE关键字。实际的表定义（所有列）括在圆括号之中，各列之间用逗号分隔。</p>
<p>在创建新的表时，指定的表名必须不存在，否则会出错。防止意外覆盖已有的表，SQL要求首先手工删除该表（请参阅后面的内容），然后再重建它，而不是简单地用创建表语句覆盖它。</p>
<p>如果该列可以为NULL，那么创建表时，可以省略最后的NULL，如上一个SQL语句的第7行，可以改为<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copyproducts</span><br><span class="line">(</span><br><span class="line">    prod_id       <span class="built_in">CHAR</span>(<span class="number">10</span>)          <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    vend_id       <span class="built_in">CHAR</span>(<span class="number">10</span>)          <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    prod_name     <span class="built_in">CHAR</span>(<span class="number">254</span>)         <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    prod_price    <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    prod_desc     <span class="built_in">text</span></span><br><span class="line">);</span></span><br></pre></td></tr></table></figure></p>
<p>指定默认值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copyorderitems</span><br><span class="line">(</span><br><span class="line">    order_num      <span class="built_in">INTEGER</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    order_item     <span class="built_in">INTEGER</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    prod_id        <span class="built_in">CHAR</span>(<span class="number">10</span>)         <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    quantity       <span class="built_in">INTEGER</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span>      <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">    item_price     <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<p>默认值还可以使用函数，比如常用的日期函数，但在MySQL中也有一定限制：MySQL的字段默认值不可以是函数，除 TIMESTAMP字段可以用CURRENT_TIMESTAMP外，其它都使用常数为默认值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> students;</span></span><br><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students</span><br><span class="line">(</span><br><span class="line">    stu_id          <span class="built_in">CHAR</span>(<span class="number">10</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    stu_name        <span class="built_in">CHAR</span>(<span class="number">10</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    createtime      <span class="keyword">timestamp</span>     <span class="keyword">not</span> <span class="literal">null</span>    <span class="keyword">default</span> <span class="keyword">current_timestamp</span></span><br><span class="line">);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">students (stu_id,</span><br><span class="line">          stu_name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">'12'</span>,</span><br><span class="line">        <span class="string">'sj'</span>);</span></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line"><span class="operator"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> students;</span></span><br></pre></td></tr></table></figure>
<h2 id="ALTER_TABLE">ALTER TABLE</h2><p>更新表<strong>定义（原有的结构）</strong>，UPDATE才是更新表里的数据。</p>
<p>对于ALTER TABLE不同的DBMS支持大不相同，MySQL的相关文档：<a href="http://doc.mysql.cn/mysql5/refman-5.1-zh.html-chapter/sql-syntax.html#alter-table" target="_blank" rel="external">时光机器</a>。</p>
<p>支持的操作：</p>
<ul>
<li>增加列。</li>
<li>删除列。</li>
<li>修改列。</li>
<li>增加限制。</li>
<li>删除主键。</li>
<li>删除索引。</li>
<li>删除外键。</li>
<li>省略。。。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">ADD</span> vend_phone <span class="built_in">CHAR</span>(<span class="number">20</span>);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告<br>使用ALTER TABLE要极为小心，应该在进行改动前做完整的备份（模式和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，也许无法删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</p>
</blockquote>
<h2 id="DROP_TABLE">DROP TABLE</h2><blockquote>
<p>警告<br>玩火需谨慎，永久性删除，不能恢复。</p>
<p>提示：使用关系规则防止意外删除<br>许多DBMS允许强制实施有关规则，防止删除与其他表相关联的表。在实施这些规则时，如果对某个表发布一条DROP TABLE语句，且该表是某个关系的组成部分，则DBMS将阻止这条语句执行，直到该关系被删除为止。如果允许，应该启用这些选项，它能防止意外删除有用的表。</p>
</blockquote>
<h2 id="重命名表">重命名表</h2><p>RENAME TABLE：对一个或多个表重命名。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span></span><br><span class="line">products <span class="keyword">TO</span> prods,</span><br><span class="line">customers <span class="keyword">TO</span> custs;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span></span><br><span class="line">prods <span class="keyword">TO</span> products,</span><br><span class="line">custs <span class="keyword">TO</span> customers;</span></span><br></pre></td></tr></table></figure>
<h1 id="视图">视图</h1><blockquote>
<p>视图，它不包含任何列或数据，包含的是一个查询。</p>
</blockquote>
<p>为什么使用视图：</p>
<ul>
<li>重用SQL语句（<strong>经常使用的SQL语句</strong>）。</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。</li>
<li>使用表的一部分而不是整个表。</li>
<li>保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<p>可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至添加和更新数据，在添加或更改这些表中的数据时，视图将返回改变过的数据。</p>
<p>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，<strong>性能可能会下降得很厉害</strong>。因此，在部署使用了大量视图的应用前，应该进行测试。</p>
<p>规则：</p>
<ul>
<li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li>
<li>对于可以创建的视图数目没有限制。</li>
<li>创建视图，必须具有足够的访问权限。这些权限通常由数据库管理人员授予。</li>
<li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的DBMS中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）。</li>
<li>许多DBMS禁止在视图查询中使用ORDER BY子句。</li>
<li>有些DBMS要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名（关于列别名的更多信息，请参阅第7课）。</li>
<li>视图不能索引，也不能有关联的触发器或默认值（因为它本身不存储数据）。</li>
<li>有些DBMS把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写回底层表。详情请参阅具体的DBMS文档。</li>
<li>有些DBMS允许创建这样的视图，它不能进行导致行不再属于视图的插入或更新。例如有一个视图，只检索带有电子邮件地址的顾客。如果更新某个顾客，删除他的电子邮件地址，将使该顾客不再属于视图。这是默认行为，而且是允许的，但有的DBMS可能会防止这种情况发生。</li>
</ul>
<p>把视图理解为一个SQL语句就好。 </p>
<h2 id="创建和删除视图">创建和删除视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> ...</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> products_customers <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, prod_id</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id</span><br><span class="line">  <span class="keyword">AND</span> orders.order_num = orderitems.order_num;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询购买RGAN01的人</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> products_customers</span><br><span class="line"><span class="keyword">WHERE</span> prod_id = <span class="string">'RGAN01'</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="用视图重新格式化检索出的数据">用视图重新格式化检索出的数据</h2><p>对于第7部分（计算字段）的一个SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(vend_name, <span class="string">' ('</span>, vend_country, <span class="string">')'</span>)</span><br><span class="line">  <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span></span><br></pre></td></tr></table></figure>
<p>我们经常使用这个格式的结果，如果每次都进行拼接，必然是麻烦的，创建一个视图，就可以重复使用它了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> vendor_location <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(vend_name, <span class="string">' ('</span>, vend_country, <span class="string">')'</span>)</span><br><span class="line">  <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> vendor_location;</span></span><br></pre></td></tr></table></figure>
<h2 id="用视图过滤不想要的数据">用视图过滤不想要的数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> customer_emaillist <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> customer_emaillist;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用视图与计算字段">使用视图与计算字段</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> order_items_expanded <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num,</span><br><span class="line">       prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> order_items_expanded</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20008</span>;</span></span><br></pre></td></tr></table></figure>
<h1 id="使用存储程序">使用存储程序</h1><blockquote>
<p>关键词：</p>
</blockquote>
<p>存储过程就是为以后使用而保存的一条或多条SQL语句。可将其视为批文件，虽然它们的作用不仅限于批处理。</p>
<p>使用存储过程有三个主要的好处，即<strong>简单、安全、高性能</strong>。</p>
<p>至于为何会简单、安全、高性能，请看下面：</p>
<ul>
<li>通过把处理封装在一个易用的单元中，可以简化复杂的操作（如前面例子所述）。</li>
<li>由于不要求反复建立一系列处理步骤，因而保证了数据的一致性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。</li>
<li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，那么只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。这一点的延伸就是安全性。通过存储过程限制对基础数据的访问，减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。</li>
<li>因为存储过程通常以编译过的形式存储，所以DBMS处理命令的工作较少，提高了性能。</li>
<li>存在一些只能用在单个请求中的SQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL版</span></span><br><span class="line">DELIMITER //</span><br><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> MailingListCount (<span class="keyword">OUT</span> ListCount <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> ListCount</span><br><span class="line">    <span class="keyword">FROM</span> Customers</span><br><span class="line">    <span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">END</span>//</span><br><span class="line">DELIMITER ;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用存储过程</span></span><br><span class="line"><span class="operator"><span class="keyword">CALL</span> MailingListCount(@ReturnValue);</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> @ReturnValue;</span></span><br></pre></td></tr></table></figure>
<p>MySQL的存储过程资料可以查看MySQL文档和网络资料，更改《SQL必知必会》中代码所参考的资料为：<br><a href="http://doc.mysql.cn/mysql5/refman-5.1-zh.html-chapter/stored-procedures.html#stored-procedure-syntax" target="_blank" rel="external">时光机1号</a>、<a href="http://blog.sina.com.cn/s/blog_52d20fbf0100ofd5.html" target="_blank" rel="external">时光机2号</a>。</p>
<p>以上代码的意思是<code>：</code>声明//为分隔符，因为MySQL使用<code>;</code>作为SQL语句的分隔符，这样可以使用<code>//</code>作为存储程序的分隔符。其中<code>ListCount</code>是整形变量，要在SQL语句中使用，最后面为调用存储过程，获取结果。</p>
<h1 id="事务">事务</h1><blockquote>
<p>关键词：要么完全执行，要么完全不执行，来维护数据库的完整性。</p>
</blockquote>
<ul>
<li>可以回退的语句：INSERT, UPDATE, DELETE。不能回退CREATE、DROP。</li>
<li>事务处理中可以使用这些语句，但进行回退时，这些操作也不撤销。</li>
</ul>
<p>管理事务的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。</p>
<p>默认情况下，MySQL采用autocommit模式运行。</p>
<h2 id="事务-1">事务</h2><p>MySQL的代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 注意行尾的分号</span></span><br><span class="line"><span class="operator"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span></span><br><span class="line">...</span><br><span class="line"><span class="operator"><span class="keyword">COMMIT</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="回退">回退</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用教材的 DELETE FROM orders 会出错，有外键限制。</span></span><br><span class="line"><span class="operator"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> copyproducts;</span></span><br><span class="line"><span class="operator"><span class="keyword">ROLLBACK</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="保留点">保留点</h2><p>回滚到设置好的点。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SAVEPOINT</span> identifier</span><br><span class="line"><span class="comment">-- do something, but run error</span></span><br><span class="line">ROALLBACK <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> identifier</span></span><br></pre></td></tr></table></figure>
<h2 id="完整例子">完整例子</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- SQL Server例子</span><br><span class="line">BEGIN TRANSACTION</span><br><span class="line">INSERT INTO Customers(cust_id, cust_name)</span><br><span class="line">VALUES('1000000010', 'Toys Emporium');</span><br><span class="line">SAVE TRANSACTION StartOrder;</span><br><span class="line">INSERT INTO Orders(order_num, order_date, cust_id)</span><br><span class="line">VALUES(20100,'2001/12/1','1000000010');</span><br><span class="line">IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;</span><br><span class="line">INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line">VALUES(20100, 1, 'BR01', 100, 5.49);</span><br><span class="line">IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;</span><br><span class="line">INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)</span><br><span class="line">VALUES(20100, 2, 'BR03', 100, 10.99);</span><br><span class="line">IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;</span><br><span class="line">COMMIT TRANSACTION</span><br></pre></td></tr></table></figure>
<p>尝试把他转换成MySQL，但IF语句，以及插入出错的方式不会写，花了半小时没找到方案。</p>
<p>如果使用C语言或者其他语言与MySQL交互，因为可以判断执行结果，会简单多了。</p>
<p>下面给出使用Python交互的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cursor.excute(<span class="string">"START TRANSACTION"</span>);</span><br><span class="line">sql = <span class="string">"INSERT INTO Customers(cust_id, cust_name) VALUES('1000000010', 'Toys Emporium')"</span></span><br><span class="line">cursor.excute(sql)</span><br><span class="line">cursor.excute(<span class="string">"SAVEPOINT startorder"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  sqls = [<span class="string">"INSERT INTO orders (order_num, order_date, cust_id) VALUES (20100, '2016/3/22', '100000010');"</span>, </span><br><span class="line">      <span class="string">"INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price) VALUES(20100, 1, 'BR01', 100, 5.49)"</span>,</span><br><span class="line">      <span class="string">"INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price) VALUES(20100, 2, 'BR03', 100, 10.99);"</span>]</span><br><span class="line">  <span class="keyword">for</span> sql <span class="keyword">in</span> sqls:</span><br><span class="line">    cursor.excute(sql)</span><br><span class="line">  db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  <span class="comment"># cursor.rollback() # rolls back any changes to the database since the last call to commit()</span></span><br><span class="line">  cursor.excute(<span class="string">"ROLLBACK TO SAVEPOINT startorder"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="游标">游标</h1><blockquote>
<p>游标（cursor）是一个存储在DBMS服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在检索出来的行中前进或后退一行或多行，这就是游标的用途所在。</p>
</blockquote>
<p>不同的DBMS支持的游标选项和特性不同。常见功能如下：</p>
<ul>
<li>能够标记游标为只读，使数据能读取，但不能更新和删除。</li>
<li>能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、相对位置等）。</li>
<li>能标记某些列为可编辑的，某些列为不可编辑的。</li>
<li>规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求可访问。</li>
<li>指示DBMS对检索出的数据（而不是指出表中活动数据）进行复制，使数据在游标打开和访问期间不变化。</li>
</ul>
<p>使用步骤：</p>
<ul>
<li>在使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句和游标选项。</li>
<li>一旦声明，就必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来。</li>
<li>对于填有数据的游标，根据需要取出（检索）各行。</li>
<li>在结束游标使用时，必须关闭游标，可能的话，释放游标（有赖于具体的DBMS）。</li>
</ul>
<p>具体看MySQL教程。</p>
<h1 id="高级SQL特性">高级SQL特性</h1><blockquote>
<p>约束、索引、触发器。</p>
</blockquote>
<h2 id="约束">约束</h2><p>管理如何插入或处理数据库数据的规则。</p>
<p>DBMS通过在数据库表上施加约束来实施引用完整性。</p>
<h3 id="主键">主键</h3><p>主键是一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动。</p>
<ul>
<li>任意两行的主键值都不相同。<ul>
<li>每行都具有一个主键值（即列中不允许NULL值）。</li>
</ul>
</li>
<li>包含主键值的列从不修改或更新。</li>
<li>主键值不能重用。如果从表中删除某一行，其主键值不分配给新行</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vendors </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> PRIMARY <span class="keyword">KEY</span> (vend_id)</span></span><br></pre></td></tr></table></figure>
<p>建立表后，为表增加主键约束，也可以创建时指定。在创建表后，统一的增加各种约束是一种良好的实践。</p>
<h3 id="外键">外键</h3><p>外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完整性的极其重要部分。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span></span><br><span class="line">FOREIGN <span class="keyword">KEY</span> (cust_id) <span class="keyword">REFERENCES</span> customers (cust_id)</span></span><br></pre></td></tr></table></figure>
<p>外键的另外作用：在定义外键后，DBMS不允许删除在另一个表中具有关联行的行。例如，不能删除关联订单的顾客。删除该顾客的唯一方法是首先删除相关的订单（这表示还要删除相关的订单项）。由于需要一系列的删除，因而利用外键可以防止意外删除数据。</p>
<p>MySQL支持称为级联删除（cascading delete）的特性。如果启用，该特性在从一个表中删除行时删除所有相关的数据。例如，如果启用级联删除并且从Customers表中删除某个顾客，则任何关联的订单行也会被自动删除。</p>
<h3 id="唯一约束">唯一约束</h3><p>唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别。</p>
<ul>
<li>表可包含多个唯一约束，但每个表只允许一个主键。</li>
<li>唯一约束列可包含NULL值。</li>
<li>唯一约束列可修改或更新。</li>
<li>唯一约束列的值可重复使用。</li>
<li>与主键不一样，唯一约束不能用来定义外键。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(wechat_id)</span></span><br></pre></td></tr></table></figure>
<h3 id="检查约束">检查约束</h3><p>检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。检查约束的常见用途有以下几点。</p>
<ul>
<li>检查最小或最大值。例如，防止0个物品的订单（即使0是合法的数）。</li>
<li>指定范围。例如，保证发货日期大于等于今天的日期，但不超过今天起一年后的日期。</li>
<li>只允许特定的值。例如，在性别字段中只允许M或F。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="keyword">CHECK</span> (gender <span class="keyword">LIKE</span> <span class="string">'[MF]'</span>)</span></span><br></pre></td></tr></table></figure>
<h2 id="索引">索引</h2><p>索引用来排序数据以加快搜索和排序操作的速度。</p>
<p>主键数据总是排序的，这是DBMS的工作。因此，按主键检索特定行总是一种快速有效的操作。但是，搜索其他列中的值通常效率不高。</p>
<p>解决方法是使用索引。可以在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表。在定义了索引后，DBMS以使用书的索引类似的方法使用它。DBMS搜索排过序的索引，找出匹配的位置，然后检索这些行。</p>
<ul>
<li>索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引。</li>
<li>索引数据可能要占用大量的存储空间。</li>
<li>并非所有数据都适合做索引。取值不多的数据（如州）不如具有更多可能值的数据（如姓或名），能通过索引得到那么多的好处。</li>
<li>索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能适合做索引。</li>
<li>可以在索引中定义多个列（例如，州加上城市）。这样的索引仅在以州加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。</li>
</ul>
<p>索引的效率随表数据的增加或改变而变化。许多数据库管理员发现，过去创建的某个理想的索引经过几个月的数据处理后可能变得不再理想了。最好定期检查索引，并根据需要对索引进行调整</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">index</span> prod_name_ind</span><br><span class="line"><span class="keyword">ON</span> products (prod_name);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>猜想<br>索引是索引列到主键的映射。索引列是有序非递减的，DBMS可以采用快速定位算法（如二分查找）索引的位置，然后得到主键，再根据主键去查找记录。</p>
</blockquote>
<h2 id="触发器">触发器</h2><p>触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发器可以与特定表上的INSERT、UPDATE和DELETE操作（或组合）相关联。</p>
<p>与存储过程不一样（存储过程只是简单的存储SQL语句），触发器与单个的表相关联。与Orders表上的INSERT操作相关联的触发器只在Orders表中插入行时执行。类似地，Customers表上的INSERT和UPDATE操作的触发器只在表上出现这些操作时执行。</p>
<p>触发器内的代码具有以下数据的访问权：</p>
<ul>
<li>INSERT操作中的所有新数据；</li>
<li>UPDATE操作中的所有新数据和旧数据；</li>
<li>DELETE操作中删除的数据。</li>
</ul>
<p>用途：</p>
<ul>
<li>保证数据一致。例如，在INSERT或UPDATE操作中将所有州名转换为大写。</li>
<li>基于某个表的变动在其他表上执行活动。例如，每当更新或删除一行时将审计跟踪记录写入某个日志表。</li>
<li>进行额外的验证并根据需要回退数据。例如，保证某个顾客的可用资金不超限定，如果已经超出，则阻塞插入。</li>
<li>计算计算列的值或更新时间戳。</li>
</ul>
<blockquote>
<p>一般来说，约束的处理比触发器快，因此在可能的时候，应该尽量使用约束。因为约束只是检查是不是符合要求，而触发器是进行修改，约束是把任务交给了上层。</p>
</blockquote>
<h2 id="数据库安全">数据库安全</h2><ul>
<li>对数据库管理功能（创建表、更改或删除已存在的表等）的访问；</li>
<li>对特定数据库或表的访问；</li>
<li>访问的类型（只读、对特定列的访问等）；</li>
<li>仅通过视图或存储过程对表进行访问；</li>
<li>创建多层次的安全措施，从而允许多种基于登录的访问和控制；</li>
<li>限制管理用户账号的能力。</li>
</ul>
<blockquote>
<p>本文使用Markdown编写。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/">SQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-project-and-custom-package" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/09/project-and-custom-package/" class="article-date">
  	<time datetime="2016-01-09T02:31:52.000Z" itemprop="datePublished">2016-01-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/09/project-and-custom-package/">对自定义包的引用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>需求驱动学习。</p>
</blockquote>
<h1 id="前言">前言</h1><p>这篇文章是包和单元测试的姊妹篇，内容是如何在自己的工程中导入自定义包，而不出现导入错误。</p>
<p>在文章：<a href="/2016/01/08/package-unittest-import-error/">包和单元测试</a>中，已经叙述了如何单元测试的导入问题，本质上讲，只要导入的模块在搜索路径中，python就可以发现该模块。也验证了<code>python</code>命令会将运行文件所在目录加到<code>sys.path</code>中，而<code>python -m unittest</code>命令，将运行命令所在目录加入到<code>sys.path</code>中。</p>
<h1 id="实验">实验</h1><p>为了写笔记，该系列实验仍然在Windows上进行，使用Python 2.7。</p>
<h2 id="1-_同级目录引用自定义包">1. 同级目录引用自定义包</h2><h4 id="目录结构">目录结构</h4><p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_project&#10;&#9;./foo&#10;&#9;&#9;./__init__.py&#10;&#9;&#9;./bar.py&#10;&#9;./tests&#10;&#9;&#9;./__init__.py&#10;&#9;&#9;./test_foo.py&#10;&#9;&#9;./test_bar.py&#10;&#9;./reference_foo_bar.py</span><br></pre></td></tr></table></figure>
<ul>
<li><code>my_project</code>是项目目录</li>
<li><code>foo</code>是包目录</li>
<li><code>tests</code>是对包的单元测试</li>
<li><code>reference_foo_bar.py</code>是与包目录同级的工程文件，即同在<code>my_project</code>下。</li>
</ul>
<h4 id="各文件内容">各文件内容</h4><ul>
<li><p>两个<code>__init__.py</code>文件、<code>test_foo.py</code>都为空</p>
</li>
<li><p><code>bar.py</code>内容：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dumb_true</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>test_bar.py</code>内容如下，但今天的实验中不会用到单元测试。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import unittest&#10;&#10;from foo import bar&#10;&#10;class TestBar(unittest.TestCase):&#10;    def test_bar_true(self):&#10;        self.assertTrue(bar.dumb_true())&#10;&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    unittest.main()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>reference_foo_bar.py</code>内容如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bar.dumb_true():</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"Hi, we can import foo and use it."</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"Hi, we also imported foo but something wrong."</span></span><br></pre></td></tr></table></figure>
<h4 id="运行测试">运行测试</h4><p>测试命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd new_project&#10;python reference_foo_bar.py</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi, we can import foo and use it.</span><br></pre></td></tr></table></figure>
<p>太棒了，这是一个好的征兆，我们成功引用了模块<code>foo.bar</code>下的<code>dumb_true</code>函数，如果不明白原理，请看姊妹篇文章：<a href="/2016/01/08/package-unittest-import-error/">包和单元测试</a></p>
<h2 id="2-_不同目录引用自定义包">2. 不同目录引用自定义包</h2><p>我们使用的标准库和第三方库，都是这种情况，因为这些包都不在我们工程的目录下。本质上讲，他们也都是自定义的，只不过在安装他们的时候，将他们所在的目录，放到了Python的搜索路径中，即<code>sys.path</code>。</p>
<p>我们本实验中自定义的包，指我们自己写的工具包，这样我们可以在自己项目中的各处都可以使用。</p>
<h4 id="目录结构-1">目录结构</h4><p>本实验目录结构如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_project&#10;&#9;./foo&#10;&#9;&#9;./__init__.py&#10;&#9;&#9;./bar.py&#10;&#9;./tests&#10;&#9;&#9;./__init__.py&#10;&#9;&#9;./test_foo.py&#10;&#9;&#9;./test_bar.py&#10;&#9;./sub_project&#10;&#9;&#9;./reference_foo_bar.py</span><br></pre></td></tr></table></figure>
<p>建立新目录<code>sub_project</code>，并将<code>reference_foo_bar.py</code>移至此目录。</p>
<h4 id="运行测试-1">运行测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd my_project&#10;python subproject\reference_foo_bar.py   #linux &#19979;&#29992;&#65306; python subproject/reference_foo_bar.py</span><br></pre></td></tr></table></figure>
<p>得错误信息：找不到模块foo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):&#10;  File &#34;sub_project\reference_foo_bar.py&#34;, line 1, in &#60;module&#62;&#10;    from foo import bar&#10;ImportError: No module named foo</span><br></pre></td></tr></table></figure>
<h4 id="问题来了">问题来了</h4><p>当前的搜索路径中包含<code>...\sub_project</code>，在本目录下是找不到<code>foo</code>的。</p>
<p>怎样才能让Python搜索到，我们自定义的包<code>foo</code>呢，</p>
<h4 id="方案1：安装我们自定义的包">方案1：安装我们自定义的包</h4><p>模仿我们安装的标准库，与第三方的包，我们可以为<code>foo</code>写一个<code>setup.py</code>，然后安装它，这样Python永远都能找到它，任何工程也都能导入它，但是我们的包不完善，需要经常修改，并且我们这个包，也仅仅适用于我们当前的工程，所以这并不是一个理想的选择。</p>
<p>打包的教程在此：<a href="https://python-packaging.readthedocs.org/en/latest/" target="_blank" rel="external">有兴趣者，请戳</a>。</p>
<h4 id="方案2：在每个文件中，修改sys-path">方案2：在每个文件中，修改<code>sys.path</code></h4><p>在每个文件中，都将<code>foo</code>所在的目录的绝对路径添加到<code>sys.path</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sys&#10;sys.path.append(absolute_path)</span><br></pre></td></tr></table></figure>
<p>但这样也存在明显的缺陷，丑陋而繁琐。</p>
<h4 id="方案3：使用相对导入">方案3：使用相对导入</h4><p><strong>这是一个馊主意。</strong></p>
<p>相对导入只在包下才能工作，所以把<code>my_project</code>变成包，然后使用相对导入。</p>
<p>在<code>py_project</code>下加入<code>__init__.py</code>，</p>
<p>修改<code>reference_foo_bar .py</code>的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from ..foo import bar&#10;&#10;if bar.dumb_true():&#10;&#9;print &#34;Hi, we can import foo and use it.&#34;&#10;else :&#10;&#9;print &#34;Hi, we also imported foo but something wrong.&#34;</span><br></pre></td></tr></table></figure>
<p>运行相对导入要掌握正确的姿势，不然，蛋碎。</p>
<p><strong>在new_project的父目录运行：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m new_project.sub_project.reference_foo_bar</span><br></pre></td></tr></table></figure>
<p>运行成功。。。<strong>但这是一个馊主意，我们总不能把我们所有的项目都搞成包吧。</strong>包可以是项目，但项目不是包。</p>
<p>所以，放弃该方法。</p>
<h1 id="参考资料">参考资料</h1><ol>
<li><p>导入原理：<br><a href="http://docs.python-guide.org/en/latest/writing/structure/" target="_blank" rel="external">http://docs.python-guide.org/en/latest/writing/structure/</a></p>
</li>
<li><p>-m 原理</p>
</li>
</ol>
<ul>
<li><a href="http://stackoverflow.com/questions/11536764/attempted-relative-import-in-non-package-even-with-init-py" target="_blank" rel="external">http://stackoverflow.com/questions/11536764/attempted-relative-import-in-non-package-even-with-init-py</a></li>
<li><a href="https://www.quora.com/What-is-the-core-reason-for-this-error-Attempted-relative-import-in-non-package-in-Python" target="_blank" rel="external">https://www.quora.com/What-is-the-core-reason-for-this-error-Attempted-relative-import-in-non-package-in-Python</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Package/">Package</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单元测试/">单元测试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-package-unittest-import-error" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/08/package-unittest-import-error/" class="article-date">
  	<time datetime="2016-01-08T13:51:23.000Z" itemprop="datePublished">2016-01-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/08/package-unittest-import-error/">Python自定义包下不同目录单元测试的导入错误</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>需求驱动学习。</p>
</blockquote>
<h1 id="前言">前言</h1><p>嗯，很绕口的标题</p>
<p>最近的项目需要把编写的工具放到tools目录，把单元测试放到test目录，造成了不同目录下导入（import）的错误。<strong>基础原因很简单，Python无法找到要导入的文件，而解决这个问题的根本方法，是向<code>sys.path</code>中添加搜索路径，如果手动添加，太俗了不是么。</strong></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Package/">Package</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单元测试/">单元测试</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/01/08/package-unittest-import-error/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-never-stop-learning" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/07/never-stop-learning/" class="article-date">
  	<time datetime="2016-01-07T12:40:34.000Z" itemprop="datePublished">2016-01-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/07/never-stop-learning/">不要限制学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>学无止境，莫限制。</p>
</blockquote>
<p>在当初学习Python的时候，对于模块，包并没有细看，当然，书籍上写的也不多，它教会了我：</p>
<ul>
<li>如何使用别人的包、模块。</li>
<li>如何写一个模块，然后在相同的目录下，使用这个模块中的类与函数。</li>
<li>如果不在同目录下，需要将模块在的目录添加到<code>sys.path</code>中。</li>
</ul>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考/">思考</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/01/07/never-stop-learning/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-things-about-github" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/27/things-about-github/" class="article-date">
  	<time datetime="2015-12-27T06:40:01.000Z" itemprop="datePublished">2015-12-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/27/things-about-github/">Github二三事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>总会有些疑问，也总有原因，也必然有解决方案。</p>
</blockquote>
<h2 id="提交者显示unknown">提交者显示unknown</h2><p>明明都是我提交的，怎么显示unkonw commit呢？</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/github-unkonw-commit.png" alt="unknown commit"></p>
<p>原因：本地Git配置的邮箱与Github上面配置的邮箱不一致，具体原因是大小写导致的，本地中有大写字母，而Github上面全为小写。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Github/">Github</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-python-unittest-in-action" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/22/python-unittest-in-action/" class="article-date">
  	<time datetime="2015-12-22T03:09:25.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/22/python-unittest-in-action/">Python单元测试实践</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文主要记录使用Python单元测试时，遇到的问题及解决办法。随着使用的增多，将会遇到更多的问题，与更多的单元测试方法。</p>
</blockquote>
<p>常用的有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertTrue, assertFalse</span><br><span class="line">assertEqual</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单元测试/">单元测试</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/22/python-unittest-in-action/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-think-about-personal-management" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/21/think-about-personal-management/" class="article-date">
  	<time datetime="2015-12-21T01:09:00.000Z" itemprop="datePublished">2015-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/21/think-about-personal-management/">个人管理的思考</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>从时间管理与记录，周计划，日计划，对理想、目标的渴望，每天告诉自己，我设定的目标。一路走来，至今，我突然开始问自己，今天的计划有助于达成我的目标吗？</p>
</blockquote>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考/">思考</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/21/think-about-personal-management/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-think-about-tree" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/21/think-about-tree/" class="article-date">
  	<time datetime="2015-12-21T01:04:23.000Z" itemprop="datePublished">2015-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/21/think-about-tree/">think about tree</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>树，树干长新支，新支又成树干，树枝上还张树叶。树叶产生的营养物质又返回树干，供树干加粗，牢固。</p>
<p>树，可以比作家庭。</p>
<p>一个组织纳新，但老成员是根基。</p>
<p>树叶也可以是泡沫，寒冬来临，叶落，树光秃秃的，那些叶子不落的公司呢，可谓有顽强生命里，华丽的度过寒冬。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考/">思考</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hexo-errors" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/13/hexo-errors/" class="article-date">
  	<time datetime="2015-12-13T04:21:33.000Z" itemprop="datePublished">2015-12-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/13/hexo-errors/">Hexo博客错误汇总</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="博文格式错误">博文格式错误</h1><h2 id="错误1">错误1</h2><p>错误提示如下：</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/13/hexo-errors/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-how-mistake-python-introduction" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/13/how-mistake-python-introduction/" class="article-date">
  	<time datetime="2015-12-13T04:13:33.000Z" itemprop="datePublished">2015-12-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/13/how-mistake-python-introduction/">翻译《Python试错》：前言</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="序言">序言</h1><p>人孰无过，但真正把事情搞糟糕，你还需要一台计算机。<br>——比尔·沃恩</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python试错/">Python试错</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/13/how-mistake-python-introduction/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-back-up-your-blog" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/12/back-up-your-blog/" class="article-date">
  	<time datetime="2015-12-12T08:31:01.000Z" itemprop="datePublished">2015-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/12/back-up-your-blog/">搭好博客勤备份</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前，在搭好博客后我就可是对博客的备份了，备份了配置文件和文章的Markdown文件，以及自己修改的主题。</p>
<p>由于备份的并不是十分勤奋，以至于在我重新做系统后，将备份到Github上的数据Clone到本地后，傻眼了。出现了以下两个大问题：</p>
<ol>
<li>少了几篇文章（一篇文章、笔记可是辛苦了好几天才写出来的呀）。</li>
<li>一些设置没有了，包括博客的自定义主题。</li>
</ol>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blog/">blog</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/12/back-up-your-blog/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Ch6-Exercises-and-Solutions-of-TADM2E" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/12/Ch6-Exercises-and-Solutions-of-TADM2E/" class="article-date">
  	<time datetime="2015-12-12T08:24:02.540Z" itemprop="datePublished">2015-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 class="title">算法设计手册第二版第六章课后习题解答</h1>



<div class="entry">

<blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Weighted-graphs-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Weighted-graphs-TADM2E</a></p>
<p>该页面答案，也是由用户编辑的，不确定是完全的正确。</p>
<h2 id="MST">MST</h2><h3 id="6-2_最短路径与MST">6-2 最短路径与MST</h3><p>题目</p>
<p>Is the path between two vertices in a minimum spanning tree necessarily a shortest path between the two vertices in the full graph? Give a proof or a counterexample.</p>
<p>解答</p>
<p>MST中两点间的路径不是该两点在整个图中的最短路径。</p>
<p><strong>反例：</strong>使用习题5-1的图，使用Kruskal得到的MST是：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-2-1.JPG" alt="习题5-1图"></p>
<a id="more"></a>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-2.JPG" alt="习题5-1图的MST"></p>
<p>路径A-&gt;I：A-&gt;D-&gt;G-&gt;J-&gt;I。路径长度为13，而在整个图中，路劲为A-&gt;I，长度为9。结果已显然。</p>
<h3 id="6-3_最短路径与MST">6-3 最短路径与MST</h3><p>题目</p>
<p>Assume that all edges in the graph have distinct edge weights (i.e., no pair of edges have the same weight). Is the path between a pair of vertices in a minimum spanning tree necessarily a shortest path between the two vertices in the full graph? Give a proof or a counterexample.</p>
<p>解答</p>
<p>否。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-3.JPG" alt="反例图及其MST"></p>
<p>考虑B到D的路径，在图中路径长度为6，而在MST中路径长度为7。</p>
<h3 id="6-4_Prim和Kruskal得到MST是否相同">6-4 Prim和Kruskal得到MST是否相同</h3><p>题目</p>
<p>Can Prim’s and Kruskal’s algorithm yield different minimum spanning trees? Explain why or why not.</p>
<p>解答</p>
<p>在6-1中，Prim与Kruskal就可以产生不同MST。只有当MST本身唯一的时候，由Prim与Kruskal得到的MST才是相同的。</p>
<p>MST唯一的条件：所有边的权值都不相同。</p>
<h3 id="6-5_Prim和Kruskal边权值是否可为负">6-5 Prim和Kruskal边权值是否可为负</h3><p>题目</p>
<p>Does either Prim’s and Kruskal’s algorithm work if there are negative edge weights? Explain why or why not.</p>
<p>解答</p>
<p>思考得到的想法和Wiki页面的想法是类似的，但我还不会严谨的证明。</p>
<p>每条边都会被访问一次，并且只是比较边的大小，既然是仅仅比较大小，那么与正负是没有关系的。不会像Dijkstra那样对边的权值有加法操作，会影响整体的结果。</p>
<h3 id="6-6_添加边，获得新的MST">6-6 添加边，获得新的MST</h3><p>题目</p>
<p>Suppose we are given the minimum spanning tree T of a given graph G (with n vertices and m edges) and a new edge e=(u,v) of weight w that we will add to G. Give an efficient algorithm to find the minimum spanning tree of the graph G+e. Your algorithm should run in O(n) time to receive full credit.</p>
<p>解答</p>
<p>向MST中添加一条边会怎样？对，出现环路。如果增加的边的权值w比从u到v的路径上最大边的权值要小，那么就需要删除掉该最大的边。</p>
<p>从u开始对MST进行DFS可以得到最大的边，时间O(n)。</p>
<p>Google了这道题目，得到了一份考卷，对该问题进行了扩展。题目及答案如下：</p>
<p>Suppose you are given a graph G=(V,E) with edge weights w(e) and a minimum spanning tree T of G. Now, suppose a new edge {u,v} is added to G. Describe (in words) a method for determining if T is still a minimum spanning tree for G.</p>
<p><em>Examine the path in T from u to v. If any vertex on this path has weight larger than that of the new edge, then T is no longer an MST. We can modify T to obtain a new MST by removing the max weight edge on this path and replacing it with the new edge.</em></p>
<p>Explain how your method can be implemented to run in O(n) time if both G and T are provided as instances of the wgraph data structure.</p>
<p><em>Using the wgraph for T, we can do a recursive tree traversal in T, starting at vertex u. Once the traversal reaches v, we “unwind” the recursion, and as we do so, we look for the max weight edge along the u,v path. The runtime for a tree traversal is O(n) and the required changes to T can be done in constant time.</em></p>
<p>Suppose that instead of a single edge, you are given a set of k new edges to add to G. For small enough k it makes sense to apply your algorithm repeatedly in order to update the MST, but if k is “too large”, it’s more efficient to re-compute the MST from scratch. How big does k have to be (as a function of m and n) in order for this to be a better choice? Assume that the MST is computed using Prim’s algorithm with a d-heap, where d=2.</p>
<p><em>When d=2, the running time for Prim’s algorithm is O(m log n), so if kn grows faster than this, it makes sense to recompute from scratch. So, if k&gt;(m/n) log n, it makes sense to recompute the MST.</em></p>
<h3 id="6-7_改变权值，MST是否改变，最短路径是否改变">6-7 改变权值，MST是否改变，最短路径是否改变</h3><p>题目</p>
<p>(a) Let T be a minimum spanning tree of a weighted graph G. Construct a new graph G′ by adding a weight of k to every edge of G. Do the edges of T form a minimum spanning tree of G′? Prove the statement or give a counterexample. </p>
<p>(b) Let P={s,…,t} describe a shortest weighted path between vertices s and t of a weighted graph G. Construct a new graph G′ by adding a weight of k to every edge of G. Does P describe a shortest path from s to t in G′? Prove the statement or give a counterexample.</p>
<p>解答</p>
<p>(a) 是的。</p>
<p>6-5中提到了，MST与权值的具体数值无关，只要能比较边的大小即可。每条边的权值都增加了k，它们依然是可以比较大小的，并且它们的相对大小并没有变化，因此T会是G’的一个MST。</p>
<p><em>这点我同答案wiki页面是不同的，那里面的回答是“可能是”。</em></p>
<p>(b) 答案不确定。</p>
<p>Dijkstra算法：只能处理非负权值的边。<br>Floyd-Warshall算法：能处理包含负边的图，但不能处理存在负边构成环的图。</p>
<ol>
<li>只要不存在负权值的边，答案是肯定的，依然是P。</li>
<li>存在负边时，我不确定。</li>
</ol>
<h3 id="6-8_已最小的代价改变MST">6-8 已最小的代价改变MST</h3><p>题目</p>
<p>Devise and analyze an algorithm that takes a weighted graph G and finds the smallest change in the cost to a non-MST edge that would cause a change in the minimum spanning tree of G. Your algorithm must be correct and run in polynomial time.</p>
<p>解答</p>
<p>polynomial time：2<sup>O(log n)</sup>, eg. n, nlogn, n<sup>10</sup>。</p>
<p>什么样的边会影响最小生成树？</p>
<p>在图的某个环中，除了这条边e，其他边都是MST中的边，那么只要e小于其中任何一条边的值就可以改变MST。</p>
<p>再详细一点，边e是环中最大的边，边x是该环剩下的边在MST中最大的边。只要使得边e的值略小于边x的值即可，这样可以保证最小的代价改变MST。</p>
<p>以6-2中的图为例，边(I,G)、(E,G)是符合条件的，减1即可，其他非MST边减的都大于1才能改变MST。</p>
<p>假设n个点，m条边，则非MST边有(m-n+1)，根据MST找到每条边所在换，并计算最小变化需要O(n)，则时间复杂度为O(n(m-n))。</p>
<p><em>我相信这不是最好的解决方案。</em></p>
<h3 id="6-9_最小连通子集">6-9 最小连通子集</h3><p>题目</p>
<p>Consider the problem of finding a minimum weight connected subset T of edges from a weighted connected graph G. The weight of T is the sum of all the edge weights in T.</p>
<p>(a) Why is this problem not just the minimum spanning tree problem? Hint: think negative weight edges.<br>(b) Give an efficient algorithm to compute the minimum weight connected subset T.</p>
<p>解答</p>
<p>若保证子图是连通的，那么T至少包含MST。向MST上添加一条边会怎样？</p>
<ol>
<li>正边：增加T的权值，不要。</li>
<li>0：不改变权值，不要。</li>
<li>负边：减小T的权值，要。</li>
</ol>
<p>因此，所有的负边都不能放过。问题来了，是先生成MST，再把所有的负边添加到MST中构成T，还是先得到所有的负边，再使用Kruskal让图连通得到T呢？</p>
<p>无论哪种方法，<strong>最后T的权值都是一样的</strong>。</p>
<ol>
<li>前面证明了，在MST的边与非MST边e构成的环中，边e之所以不在MST中，就是因为它是环里面最大的，虽然现在边e的权值是负的，但仍然是最大的，因此把e添加进来，不会造成要删除其他MST边。最后得到的T的权值必然是最小的。</li>
<li>先得所有负边，在Kruskal得到的T的权值必然也是最小的，因为它一直都在选最小的边。</li>
</ol>
<h3 id="6-10_feedback-edge_set">6-10 feedback-edge set</h3><p>题目</p>
<p>Let G=(V,E) be an undirected graph. A set F⊆E of edges is called a feedback-edge set if every cycle of G has at least one edge in F.</p>
<p>(a) Suppose that G is unweighted. Design an efficient algorithm to find a minimum-size feedback-edge set.<br>(b) Suppose that G is a weighted undirected graph with positive edge weights. Design an efficient algorithm to find a minimum-weight feedback-edge set.</p>
<p>解答</p>
<p>(a)</p>
<ol>
<li>记录每条边属于哪些环。</li>
<li>拥有最多环的那条边e加入F。</li>
<li>更新每条边，删除它们e中拥有的边，此时e拥有的边变为了0个。</li>
<li>重复2-3，直到所有边不拥有环。</li>
</ol>
<p>时间复杂度嘛，看样子还是不小的。要找到么一个环，然后标记每条边在几个环内，还要排序，删除，不是一个高效的方案。</p>
<p>(b)</p>
<h2 id="并查集">并查集</h2><h3 id="6-12_设计并查集及算法">6-12 设计并查集及算法</h3><p>题目</p>
<p>Devise an efficient data structure to handle the following operations on a weighted directed graph:</p>
<p>(a) Merge two given components.<br>(b) Locate which component contains a given vertex v.<br>(c) Retrieve a minimum edge from a given component.</p>
<p>解答</p>
<p>在课本的并查集操作，得到的并查集是这样的。<br><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-12 b.png" alt="原始并查集结果"></p>
<p>要想确定两个顶点在不在一个集合内，需要找到代表这个集合的根节点，find的效率并不高，他需要多次递归才能得到根节点。</p>
<p>如果能提高find的效率，并查集的操作也将提高很多。常见的做法是，<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="external">路径压缩</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(set_union *s, <span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;p[x] != x)</span><br><span class="line">        s-&gt;p[x] = find(s, s-&gt;p[x]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s-&gt;p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径">最短路径</h2><h3 id="6-14_单目的最短路径">6-14 单目的最短路径</h3><p>题目</p>
<p>The <em>single-destination shortest path</em> problem for a <strong>directed graph</strong> seeks the shortest path from every vertex to a specified vertex v. Give an efficient algorithm to solve the single-destination shortest paths problem.</p>
<p>解答</p>
<p>如果是无向图的话，执行Dijkstra算法即可，然后倒转所有的路径。但是，题目指明是基于有向图的问题。</p>
<p>另外，Kruskal算法是All-Pairs最短路径，如果想到的算法时间复杂度大于O(n<sup>3</sup>)，那还不如直接使用Kruskal。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-14.png" alt="6-14图"></p>
<p>如上图,假设要求从s到t的最短路径，并且已经求得c1,c2,c3到t的最短路径，那么s到t的最短路径应当为 <code>W[s,t] = min(W[s,c1]+W[c1,t], W[s,c2]+W[c2,t], W[s,c3]+W[c3,t])</code>。</p>
<p>自然而然，应当想到了递归解法。Oh，接下来貌似你要考虑一下这些问题：</p>
<ol>
<li>从哪个点开始递归，可以向dfs中那样使用for循环</li>
<li>怎么处理环</li>
<li>。。。</li>
</ol>
<p>再回首想想：<strong>图的解决方案，是对图进行建模，使用已有的算法，而不是设计新的算法</strong></p>
<p>使用Dijkstra算法。反向建立图G’ = (V’,E’), V = V’, {u,v}∈E, {v,u}属于E’。对G’使用Dijkstra算法得到从v到任意节点的最短路径，倒转所有路径即从所有节点到v的最短路径。</p>
<h3 id="6-16_MST与SPT">6-16 MST与SPT</h3><p>题目</p>
<p>Answer all of the following:</p>
<p>(a) Give an example of a weighted connected graph G=(V,E) and a vertex v, such that the minimum spanning tree of G is the same as the shortest-path spanning tree rooted at v.<br>(b) Give an example of a weighted connected directed graph G=(V,E) and a vertex v, such that the <em>minimum-cost spanning tree</em> of G is very different from the shortest-path spanning tree rooted at v.<br>(c) Can the two trees be completely disjointed?</p>
<p>解答</p>
<p>(a) 图G、MST、SP构成的树都是下图：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-16 a.png" alt="Ex 6-16 a"></p>
<p>(b) minimum-cost spanning tree就是MST，看到这个刚开始还觉得这是不是一个新东西。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-16 b.png" alt="Ex 6-16 b"></p>
<p>(c) What is ‘completely disjointed’?</p>
<h3 id="6-17_MST的边与SP的边">6-17 MST的边与SP的边</h3><p>题目</p>
<p>Either prove the following or give a counterexample:</p>
<p>(a) Is the path between a pair of vertices in a minimum spanning tree of an undirected graph necessarily the shortest (minimum weight) path?<br>(b) Suppose that the minimum spanning tree of the graph is unique. Is the path between a pair of vertices in a minimum spanning tree of an undirected graph necessarily the shortest (minimum weight) path?</p>
<p>解答</p>
<p>(a) 否。见上题(b)。边(A,C)就不在最短路径中。</p>
<p>(b) 否。见上题(b)。图G的MST是唯一的，那么现在又回到了题(a)。</p>
<h3 id="6-18_顶点有权值">6-18 顶点有权值</h3><p>题目</p>
<p>In certain graph problems, vertices have can have weights instead of or in addition to the weights of edges. Let Cv be the cost of vertex v, and C(x,y) the cost of the edge (x,y). This problem is concerned with finding the cheapest path between vertices a and b in a graph G. The cost of a path is the sum of the costs of the edges and vertices encountered on the path.</p>
<p>(a) Suppose that each edge in the graph has a weight of zero (while non-edges have a cost of ∞). Assume that Cv=1 for all vertices 1≤v≤n (i.e., all vertices have the same cost). Give an efficient algorithm to find the cheapest path from a to b and its time complexity.<br>(b) Now suppose that the vertex costs are not constant (but are all positive) and the edge costs remain as above. Give an efficient algorithm to find the cheapest path from a to b and its time complexity.<br>(c) Now suppose that both the edge and vertex costs are not constant (but are all positive). Give an efficient algorithm to find the cheapest path from a to b and its time complexity.</p>
<p>解答</p>
<blockquote>
<p>6.3.1 Stop and Think<br>Set the weight of each directed edge{i,j} in the input graph to the cost of vertex j. Dijkstra’s algorithm now does the job.</p>
</blockquote>
<p>我的解决方案：</p>
<p>设边{i,j}的权值为W[i,j]。则将其改为W[i,j] = W[i,j] + C<sub>j</sub>，然后使用Dijkstra。</p>
<p>W[i,j]初始化：<br>(a) W[i,j] = 0.<br>(b) W[i,j] = k(常数).<br>(c) W[i,j] 原本值。</p>
<h3 id="6-19_最小有向环">6-19 最小有向环</h3><p>题目</p>
<p>Let G be a weighted directed graph with n vertices and m edges, where all edges have positive weight. A directed cycle is a directed path that starts and ends at the same vertex and contains at least one edge. Give an O(n<sup>3</sup>) algorithm to find a directed cycle in G of minimum total weight. Partial credit will be given for an O(n<sup>2</sup>m) algorithm.</p>
<p>解答</p>
<p>如果对Floyd的过程比较了解，这个真的很简单，因为Floyd得到的是All-pairs，包括了i到i的最短距离，即<code>g-&gt;weight[i][i]</code>。遍历便可的最小值。</p>
<p>我在做Floyd的时候，对有向图做了测试，<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/floyd.c" target="_blank" rel="external">github传送门</a>。</p>
<h3 id="6-20_最长路径">6-20 最长路径</h3><p>题目</p>
<p>Can we modify Dijkstra’s algorithm to solve the single-source longest path problem by changing {\em minimum} to maximum? If so, then prove your algorithm correct. If not, then provide a counterexample.</p>
<p>解答</p>
<p>Longest path is basically the <em>Hamiltonian Cycle problem</em> or the <em>Traveling Salesman Problem</em>, and it is NP-hard. So no, and if you find a way, then P=NP.</p>
<p>The existence or non-existence of an algorithm to find the largest path, in polynomial time, is essentially part of the largest open problem in all of CS (and probably in math).</p>
<p><a href="http://cs.stackexchange.com/questions/17980/is-it-possible-to-modify-dijkstra-algorithm-in-order-to-get-the-longest-path" target="_blank" rel="external">参考资料1</a><br><a href="http://cs.stackexchange.com/questions/10732/how-to-prove-np-hardness-of-a-longest-path-problem" target="_blank" rel="external">参考资料2</a></p>
<h3 id="6-21_SSSP_线性时间">6-21 SSSP 线性时间</h3><p>题目</p>
<p>Let G=(V,E) be a weighted acyclic directed graph with possibly negative edge weights. Design a linear-time algorithm to solve the single-source shortest-path problem from a given source v.</p>
<p>解答</p>
<ol>
<li><p>使用拓扑排序：O(E+V)<br><a href="http://en.wikipedia.org/wiki/Topological_sorting#Application_to_shortest_path_finding" target="_blank" rel="external">参考资料</a></p>
</li>
<li><p>Google: linear-time algorithm to solve the single-source shortest-path, 会搜到几篇论文，解决方案是修改Dijkstra算法。</p>
</li>
</ol>
<h3 id="6-22_长度为k的最短路径">6-22 长度为k的最短路径</h3><p>题目</p>
<p>Let G=(V,E) be a directed weighted graph such that all the weights are positive. Let v and w be two vertices in G and k≤|V| be an integer. Design an algorithm to find the shortest path from v to w that contains exactly k edges. Note that the path need not be simple.</p>
<p>解答</p>
<p>注意最后一句：意味着图可能存在环的，并且路径中也可以存在环。</p>
<p>比如图为：A&lt;-&gt;B，v=A, w=B.<br>k=1时，A-&gt;B;<br>k=2时，不存在。<br>k=3时，A-&gt;B-&gt;A-&gt;B。</p>

      
    </div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Ch7-Exercises-and-Solutions-of-TADM2E" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/12/Ch7-Exercises-and-Solutions-of-TADM2E/" class="article-date">
  	<time datetime="2015-12-12T07:43:28.234Z" itemprop="datePublished">2015-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>算法设计手册第二版第七章课后习题解答</h1>
    <div class="entry">
      

        
        <blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Search-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Search-TADM2E</a></p>
<p>该页面答案，也是由用户编辑的，不确定是完全的正确。</p>
<h2 id="Backtracking">Backtracking</h2><h3 id="7-1_permutations">7-1 permutations</h3><p>题目</p>
<p>A derangement is a permutation p of {1,…,n} such that no item is in its proper position, i.e. pi≠i for all 1≤i≤n. derangement Write an efficient backtracking program with pruning that constructs all the derangements of n items.</p>
<p>解答</p>
<p>剪枝就是构建合适的候选者。只需增加一个限制条件<code>i != k</code>。<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/7.11/7_1_permutations.c" target="_blank" rel="external">完整代码</a>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> construct_candidates(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> c[], <span class="keyword">int</span> *ncandidates)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">bool</span> in_perm[NMAX];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;NMAX; ++i) in_perm[i] = <span class="literal">FALSE</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;k; ++i)  in_perm[a[i]] = <span class="literal">TRUE</span>;</span><br><span class="line">  *ncandidates = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i != k &amp;&amp; in_perm[i] == <span class="literal">FALSE</span>) <span class="comment">// pruning</span></span><br><span class="line">      c[(*ncandidates)++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2_Multisets">7-2 Multisets</h3><p>题目</p>
<p>Multisets are allowed to have repeated elements. A multiset of n items may thus have fewer than n! distinct permutations. For example, {1,1,2,2} has only six different permutations: {1,1,2,2}, {1,2,1,2}, {1,2,2,1}, {2,1,1,2}, {2,1,2,1}, and {2,2,1,1}. multiset Design and implement an efficient algorithm for constructing all permutations of a multiset.</p>
<p>解答</p>
<p>在每次选取候选者的时候，重复的候选者，只选择一个，就不会出现同一个数字在同一个位置，出现多次。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mulset[NMAX];            <span class="comment">// Multisets</span></span><br><span class="line">a[];                     <span class="comment">// save the indexes of the number in mulset</span></span><br><span class="line"><span class="keyword">void</span> construct_candidates(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> c[], <span class="keyword">int</span> *ncandidates)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">bool</span> in_perm[NMAX];   <span class="comment">// save the indexes of the number in mulset</span></span><br><span class="line">  <span class="keyword">int</span> uniset[NMAX];     <span class="comment">// save the first indexes of a number in mulset</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;NMAX; ++i) in_perm[i] = <span class="literal">FALSE</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;k; ++i)  in_perm[a[i]] = <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">  get_unique_set(in_perm, uniset); </span><br><span class="line"></span><br><span class="line">  *ncandidates = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i != k &amp;&amp; uniset[i] == <span class="literal">FALSE</span>) <span class="comment">// pruning</span></span><br><span class="line">      c[(*ncandidates)++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3_图的同构">7-3 图的同构</h3><p>题目</p>
<p>Design and implement an algorithm for testing whether two graphs are isomorphic to each other. The graph isomorphism problem is discussed in graph-isomorphism. With proper pruning, graphs on hundreds of vertices can be tested reliably.</p>
<p>解答</p>
<p>NP问题。</p>
<p>方法就是进行验证。</p>
<p>以无向图举例。</p>
<ol>
<li>顶点数量相同。</li>
<li>在图G中任选一点，依次与图H中的点进行匹配。</li>
<li>那么总的配对方式供NxN个。</li>
<li>验证方式是：图G中有的边，图H中也有，图H中有的边图G中也有。</li>
</ol>
<p>剪枝：仅将H中与G中当前顶点度相同的顶点加入到候选者列表。</p>
<h3 id="7-4">7-4</h3><p>题目</p>
<p>Anagrams are rearrangements of the letters of a word or phrase into a different word or phrase. Sometimes the results are quite striking. For example, “MANY VOTED BUSH RETIRED” is an anagram of “TUESDAY NOVEMBER THIRD”, which correctly predicted the result of the 1992 U.S. presidential election. Design and implement an algorithm for finding anagrams using combinatorial search and a dictionary.</p>
<p>解答</p>
<ol>
<li>根据输入字符串，拆解得到一个字符池。池中字母保持字典顺序。</li>
<li>按照课本构造子集的方式，得到一个子集，即一个“单词”，判断该单词在不在词典中？<br> 2.1 在，则从剩下的字符池继续构建单词，直到池为空，得到一个solution；<br> 2.2 否，构建下一个单词。</li>
</ol>

      
    </div>
    
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Well-Prepared-For-Campus-Recruit" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/01/Well-Prepared-For-Campus-Recruit/" class="article-date">
  	<time datetime="2015-12-01T10:32:13.000Z" itemprop="datePublished">2015-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/01/Well-Prepared-For-Campus-Recruit/">校园招聘哪些事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>打算分为以下几个方面记录一些校园资料。虽然大部分都被我存到笔记软件中，以后就放这里吧。笔记软件里面的东西越来越多，尽管已经为每篇笔记设置了标签和分类，但依然有点冗肿了，并且搜索有点慢。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/招聘/">招聘</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/01/Well-Prepared-For-Campus-Recruit/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 随风
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>