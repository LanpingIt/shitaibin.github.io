<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>随风</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="屌丝程序员的自留地#为搜索引擎留的">
<meta property="og:type" content="website">
<meta property="og:title" content="随风">
<meta property="og:url" content="http://shitaibin.github.io/index.html">
<meta property="og:site_name" content="随风">
<meta property="og:description" content="屌丝程序员的自留地#为搜索引擎留的">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="随风">
<meta name="twitter:description" content="屌丝程序员的自留地#为搜索引擎留的">
  
    <link rel="alternative" href="/atom.xml" title="随风" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xixtr.com1.z0.glb.clouddn.com/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">随风</a></h1>
		</hgroup>

		
		<p class="header-subtitle">随风而起，随风而散</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shitaibin" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Github-Pages/" style="font-size: 10px;">Github Pages</a> <a href="/tags/Hexo/" style="font-size: 20px;">Hexo</a> <a href="/tags/Package/" style="font-size: 13.33px;">Package</a> <a href="/tags/Python/" style="font-size: 16.67px;">Python</a> <a href="/tags/Python试错/" style="font-size: 10px;">Python试错</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/TADM/" style="font-size: 13.33px;">TADM</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/单元测试/" style="font-size: 16.67px;">单元测试</a> <a href="/tags/图论/" style="font-size: 10px;">图论</a> <a href="/tags/待办/" style="font-size: 10px;">待办</a> <a href="/tags/思考/" style="font-size: 16.67px;">思考</a> <a href="/tags/招聘/" style="font-size: 10px;">招聘</a> <a href="/tags/排序/" style="font-size: 10px;">排序</a> <a href="/tags/搜索/" style="font-size: 13.33px;">搜索</a> <a href="/tags/编程语言/" style="font-size: 10px;">编程语言</a> <a href="/tags/翻译/" style="font-size: 10px;">翻译</a> <a href="/tags/面试/" style="font-size: 13.33px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">随风</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xixtr.com1.z0.glb.clouddn.com/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">随风</h1>
			</hgroup>
			
			<p class="header-subtitle">随风而起，随风而散</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shitaibin" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-review-SQL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/13/review-SQL/" class="article-date">
  	<time datetime="2016-03-13T06:47:20.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/review-SQL/">SQL回顾总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本博文中的所有内容，可以在MySQL中运行。</p>
</blockquote>
<p>MySQL 5.1在线参考手册：<a href="http://doc.mysql.cn/mysql5/refman-5.1-zh.html-chapter/" target="_blank" rel="external">时光机</a></p>
<h1 id="查询">查询</h1><h2 id="限制行号和偏倚量。">限制行号和偏倚量。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>,<span class="number">3</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="注释">注释</h2><p>1) 嵌入在行内<br>2) 整行都是注释<br>3) 块注释</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="comment">--</span></span><br><span class="line">2) #</span><br><span class="line">3) <span class="comment">/*  */</span></span><br></pre></td></tr></table></figure>
<h1 id="检索排序">检索排序</h1><blockquote>
<p>关键字：ORDER BY，DESC。</p>
</blockquote>
<h2 id="ORDER_BY子句的位置（必须最后一句）">ORDER BY子句的位置（必须最后一句）</h2><p>  在指定一条ORDER BY子句时，应该保证它是SELECT语句中最后一条子句。如果它不是最后的子句，将会出现错误消息。</p>
<h2 id="通过非选择列进行排序（排序的那列可以不显示）">通过非选择列进行排序（排序的那列可以不显示）</h2><p>  通常，ORDER BY子句中使用的列将是为显示而选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。</p>
<h2 id="多列排序">多列排序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price, prod_name;</span></span><br></pre></td></tr></table></figure>
<p>效果<br><img src="http://7xixtr.com1.z0.glb.clouddn.com/review-SQL-3-1.png" alt=""></p>
<p>为什么列顺序不是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price, prod_name;</span></span><br></pre></td></tr></table></figure>
<p>效果<br><img src="http://7xixtr.com1.z0.glb.clouddn.com/review-SQL-3-2.png" alt=""></p>
<p>因为<code>prod_name</code>放中间不好看。</p>
<h2 id="按列位置排序">按列位置排序</h2><p><strong>禁止使用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span>, <span class="number">3</span>;</span></span><br></pre></td></tr></table></figure>
<p>虽然简写了列名字，但容易出错，并且相当不直观，隐藏了潜在BUG。在修改SQL的语句的更容易错误，可能依据的排序列根本不在查询中。</p>
<h2 id="逆序">逆序</h2><p>在排序依据列的名字加DESC。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name <span class="keyword">DESC</span>;</span></span><br></pre></td></tr></table></figure>
<p>效果：根据价格从高到低排序，同价，则根据名字，从后向前排序。</p>
<h1 id="检索过滤">检索过滤</h1><blockquote>
<p>关键词：WHERE。</p>
</blockquote>
<h2 id="操作符">操作符</h2><p><img src="http://7xixtr.com1.z0.glb.clouddn.com/review-SQL-operators.png" alt=""></p>
<h2 id="范围检查">范围检查</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">8</span> <span class="keyword">AND</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="空值检查">空值检查</h2><p>IS NULL。</p>
<p><strong>这不同于值为0，或字符串为空。</strong></p>
<p>查找没有邮箱的客户。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cust_name</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="literal">NULL</span>;</span></span><br></pre></td></tr></table></figure>
<p>找到有邮箱的用户。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cust_name</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span></span><br></pre></td></tr></table></figure>
<h1 id="高级过滤">高级过滤</h1><blockquote>
<p>关键词：NOT，IN，AND，OR。</p>
</blockquote>
<h2 id="AND,_OR">AND, OR</h2><p>WHERE子句可以包含任意数目的AND和OR操作符。允许两者结合以进行复杂、高级的过滤。SQL（像多数语言一样）<strong>在处理OR操作符前，优先处理AND操作符</strong>。当SQL看到上述WHERE子句时，它理解为：由供应商BRS01制造的价格为10美元以上的所有产品，以及由供应商DLL01制造的所有产品，而不管其价格如何。换句话说，由于AND在求值过程中优先级更高，操作符被错误地组合了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="string">'DLL01'</span> <span class="keyword">OR</span> vend_id = ‘BRS01’</span><br><span class="line"><span class="keyword">AND</span> prod_price &gt;= <span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>理想是这样子的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> (vend_id = <span class="string">'DLL01'</span> <span class="keyword">OR</span> vend_id = ‘BRS01’)</span><br><span class="line"><span class="keyword">AND</span> prod_price &gt;= <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="IN">IN</h2><p>满足所在集合的记录。</p>
<ol>
<li><strong>完成的是OR的工作，IN是OR的简洁版本</strong>。</li>
<li>在有很多合法选项时，IN操作符的语法<strong>更清楚，更直观</strong>。</li>
<li>在与其他AND和OR操作符组合使用IN时，求值顺序更<strong>容易管理</strong>。</li>
<li>IN操作符一般比一组OR操作符执行得<strong>更快</strong>。</li>
<li>IN的最大优点是可以<strong>包含其他SELECT语句，能够更动态地建立WHERE子句</strong>。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id</span><br><span class="line"><span class="keyword">IN</span> (<span class="string">'DLL01'</span>, <span class="string">'BRS01'</span>);</span></span><br></pre></td></tr></table></figure>
<h2 id="NOT">NOT</h2><p>WHERE子句中的NOT操作符有且只有一个功能，那就是否定<strong>其后</strong>所跟的任何条件。<br>在更复杂的子句中，NOT是非常有用的。例如，在与IN操作符联合使用时，NOT可以非常简单地找出与条件列表不匹配的行。</p>
<h1 id="通配符过滤">通配符过滤</h1><blockquote>
<p>关键词：%，_。</p>
</blockquote>
<p>引用自《SQL必知必会》。</p>
<blockquote>
<p>通配符（wildcard）<br>用来匹配值的一部分的特殊字符。</p>
<p>搜索模式（search pattern）<br>由字面值、通配符或两者组合构成的搜索条件。</p>
</blockquote>
<p>通配符本身实际上是SQL的WHERE子句中有特殊含义的字符，SQL支持几种通配符。为在搜索子句中使用通配符，必须使用LIKE操作符。LIKE指示DBMS，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。</p>
<blockquote>
<p>谓词（predicate）<br>操作符何时不是操作符？答案是，它作为谓词时。从技术上说，LIKE是谓词而不是操作符。虽然最终的结果是相同的，但应该对此术语有所了解，以免在SQL文献或手册中遇到此术语时不知所云。</p>
</blockquote>
<h2 id="谓词：LIKE">谓词：<code>LIKE</code></h2><h2 id="%：任何字符出现任意次数">%：任何字符出现任意次数</h2><ol>
<li>使用相当的灵活，可以把<code>%</code>放在字符串的任何一个位置，也可以使用多个<code>%</code>。</li>
<li>不匹配<code>NULL</code>。</li>
</ol>
<p>搜索商品名称以Fish开头的商品。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_name </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'Fish%'</span>;</span></span><br></pre></td></tr></table></figure>
<p>以bag结尾呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE prod_name LIKE '%bag';</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'F%y' ： 以F开头，以y结尾。</span><br><span class="line">'F%y%'：以F开头，中间有y。</span><br></pre></td></tr></table></figure>
<p>实用案例：邮箱匹配</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> cust_name, cust_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">LIKE</span> <span class="string">'%@fun4all.com'</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="_：只匹配单个字符。">_：只匹配单个字符。</h2><ol>
<li>有且仅有一个字符。</li>
<li>可以是空格。</li>
<li>可以连用。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'__ inch teddy bear'</span>;</span></span><br></pre></td></tr></table></figure>
<p><strong>MySQL的LIKE只支持<code>%</code>和<code>_</code>，其他匹配，可以使用谓词<code>REGEXP</code>。</strong></p>
<h2 id="技巧">技巧</h2><ol>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>
</ol>
<h1 id="计算字段">计算字段</h1><blockquote>
<p>字段（field）<br>基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常与计算字段一起使用。</p>
</blockquote>
<h2 id="拼接">拼接</h2><p>MySQL需要使用拼接函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">concat(): 参数为列名，和字符串</span><br><span class="line">concat_ws(): 第一个参数为连接符，剩余参数为列明，各列之间使用连接符连接</span><br></pre></td></tr></table></figure>
<p>例1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(vend_name, <span class="string">'('</span>, vend_country, <span class="string">')'</span>)</span><br><span class="line">	<span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors;</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">'Bear Emporium(USA)'</span><br><span class="line">'Bears R Us(USA)'</span><br><span class="line">'Doll House Inc.(USA)'</span><br><span class="line">'Fun and Games(England)'</span><br><span class="line">'Furball Inc.(USA)'</span><br><span class="line">'Jouets et ours(France)'</span><br></pre></td></tr></table></figure>
<p>例2</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">concat_ws</span>(<span class="string">'-'</span>, vend_name, vend_country)</span><br><span class="line"><span class="keyword">FROM</span> vendors;</span></span><br></pre></td></tr></table></figure>
<p>效果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">'Bear Emporium-USA'</span><br><span class="line">'Bears R Us-USA'</span><br><span class="line">'Doll House Inc.-USA'</span><br><span class="line">'Fun and Games-England'</span><br><span class="line">'Furball Inc.-USA'</span><br><span class="line">'Jouets et ours-France'</span><br></pre></td></tr></table></figure>
<h2 id="别名/导出列">别名/导出列</h2><p>AS是SQL的一条最佳实践。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">concat_ws</span>(<span class="string">'-'</span>, vend_name, vend_country)</span><br><span class="line">	<span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> vendors;</span></span><br></pre></td></tr></table></figure>
<h2 id="算术计算">算术计算</h2><p>支持列或字段之间的四则运算。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">	   quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity*item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line"><span class="keyword">WHERE</span> order_num = <span class="number">20008</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>SELECT语句校验<br>SELECT语句为测试、检验函数和计算提供了很好的方法。虽然SELECT通常用于从表中检索数据，但是省略了FROM子句后就是简单地访问和处理表达式，例如SELECT 3 * 2;将返回6，SELECT Trim(‘ abc ‘);将返回abc，SELECT Now();使用Now()函数返回当前日期和时间。现在你明白了，可以根据需要使用SELECT语句进行检验。</p>
</blockquote>
<h1 id="函数">函数</h1><blockquote>
<p>不同的DBMS支持的函数不同。</p>
</blockquote>
<p>常用函数可以分为以下几类：</p>
<ul>
<li>数值函数</li>
<li>文本函数</li>
<li>日期时间函数</li>
<li>DBMS系统函数</li>
</ul>
<p>常用函数参考：<a href="http://www.cnblogs.com/kissdodog/p/4168721.html" target="_blank" rel="external">时光机</a></p>
<h2 id="文本函数">文本函数</h2><p>处理字符串的函数。</p>
<p>例1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> vend_name,</span><br><span class="line">  <span class="keyword">upper</span>(vend_name) <span class="keyword">AS</span> vend_name_upcase</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span></span><br></pre></td></tr></table></figure>
<h2 id="日期时间函数">日期时间函数</h2><p>日期和时间采用相应的数据类型存储在表中，<strong>每种DBMS都有自己的特殊形式</strong>。日期和时间值以特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。</p>
<p>应用程序一般不使用日期和时间的存储格式，因此日期和时间函数总是用来读取、统计和处理这些值。由于这个原因，日期和时间函数在SQL中具有重要的作用。遗憾的是，它们很不一致，<strong>可移植性最差</strong>。</p>
<p><strong>时间函数相当的丰富，包含了各种转换，日期加减，抽取。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">curdate</span>();</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">curtime</span>();</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">now</span>();</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">month</span>(<span class="string">"2016-3-13 1:1:1"</span>);</span> <span class="comment">-- 获取输入date的月份</span></span><br></pre></td></tr></table></figure>
<h2 id="数值处理">数值处理</h2><p><strong>在各大DBMS中，最统一、最一致的函数。</strong></p>
<p>主要包括代数、三角、几何运算。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/">SQL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-project-and-custom-package" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/09/project-and-custom-package/" class="article-date">
  	<time datetime="2016-01-09T02:31:52.000Z" itemprop="datePublished">2016-01-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/09/project-and-custom-package/">对自定义包的引用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>需求驱动学习。</p>
</blockquote>
<h1 id="前言">前言</h1><p>这篇文章是包和单元测试的姊妹篇，内容是如何在自己的工程中导入自定义包，而不出现导入错误。</p>
<p>在文章：<a href="/2016/01/08/package-unittest-import-error/">包和单元测试</a>中，已经叙述了如何单元测试的导入问题，本质上讲，只要导入的模块在搜索路径中，python就可以发现该模块。也验证了<code>python</code>命令会将运行文件所在目录加到<code>sys.path</code>中，而<code>python -m unittest</code>命令，将运行命令所在目录加入到<code>sys.path</code>中。</p>
<h1 id="实验">实验</h1><p>为了写笔记，该系列实验仍然在Windows上进行，使用Python 2.7。</p>
<h2 id="1-_同级目录引用自定义包">1. 同级目录引用自定义包</h2><h4 id="目录结构">目录结构</h4><p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_project&#10;&#9;./foo&#10;&#9;&#9;./__init__.py&#10;&#9;&#9;./bar.py&#10;&#9;./tests&#10;&#9;&#9;./__init__.py&#10;&#9;&#9;./test_foo.py&#10;&#9;&#9;./test_bar.py&#10;&#9;./reference_foo_bar.py</span><br></pre></td></tr></table></figure>
<ul>
<li><code>my_project</code>是项目目录</li>
<li><code>foo</code>是包目录</li>
<li><code>tests</code>是对包的单元测试</li>
<li><code>reference_foo_bar.py</code>是与包目录同级的工程文件，即同在<code>my_project</code>下。</li>
</ul>
<h4 id="各文件内容">各文件内容</h4><ul>
<li><p>两个<code>__init__.py</code>文件、<code>test_foo.py</code>都为空</p>
</li>
<li><p><code>bar.py</code>内容：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dumb_true</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>test_bar.py</code>内容如下，但今天的实验中不会用到单元测试。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import unittest&#10;&#10;from foo import bar&#10;&#10;class TestBar(unittest.TestCase):&#10;    def test_bar_true(self):&#10;        self.assertTrue(bar.dumb_true())&#10;&#10;&#10;if __name__ == &#34;__main__&#34;:&#10;    unittest.main()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>reference_foo_bar.py</code>内容如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bar.dumb_true():</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"Hi, we can import foo and use it."</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">	<span class="keyword">print</span> <span class="string">"Hi, we also imported foo but something wrong."</span></span><br></pre></td></tr></table></figure>
<h4 id="运行测试">运行测试</h4><p>测试命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd new_project&#10;python reference_foo_bar.py</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi, we can import foo and use it.</span><br></pre></td></tr></table></figure>
<p>太棒了，这是一个好的征兆，我们成功引用了模块<code>foo.bar</code>下的<code>dumb_true</code>函数，如果不明白原理，请看姊妹篇文章：<a href="/2016/01/08/package-unittest-import-error/">包和单元测试</a></p>
<h2 id="2-_不同目录引用自定义包">2. 不同目录引用自定义包</h2><p>我们使用的标准库和第三方库，都是这种情况，因为这些包都不在我们工程的目录下。本质上讲，他们也都是自定义的，只不过在安装他们的时候，将他们所在的目录，放到了Python的搜索路径中，即<code>sys.path</code>。</p>
<p>我们本实验中自定义的包，指我们自己写的工具包，这样我们可以在自己项目中的各处都可以使用。</p>
<h4 id="目录结构-1">目录结构</h4><p>本实验目录结构如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_project&#10;&#9;./foo&#10;&#9;&#9;./__init__.py&#10;&#9;&#9;./bar.py&#10;&#9;./tests&#10;&#9;&#9;./__init__.py&#10;&#9;&#9;./test_foo.py&#10;&#9;&#9;./test_bar.py&#10;&#9;./sub_project&#10;&#9;&#9;./reference_foo_bar.py</span><br></pre></td></tr></table></figure>
<p>建立新目录<code>sub_project</code>，并将<code>reference_foo_bar.py</code>移至此目录。</p>
<h4 id="运行测试-1">运行测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd my_project&#10;python subproject\reference_foo_bar.py   #linux &#19979;&#29992;&#65306; python subproject/reference_foo_bar.py</span><br></pre></td></tr></table></figure>
<p>得错误信息：找不到模块foo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):&#10;  File &#34;sub_project\reference_foo_bar.py&#34;, line 1, in &#60;module&#62;&#10;    from foo import bar&#10;ImportError: No module named foo</span><br></pre></td></tr></table></figure>
<h4 id="问题来了">问题来了</h4><p>当前的搜索路径中包含<code>...\sub_project</code>，在本目录下是找不到<code>foo</code>的。</p>
<p>怎样才能让Python搜索到，我们自定义的包<code>foo</code>呢，</p>
<h4 id="方案1：安装我们自定义的包">方案1：安装我们自定义的包</h4><p>模仿我们安装的标准库，与第三方的包，我们可以为<code>foo</code>写一个<code>setup.py</code>，然后安装它，这样Python永远都能找到它，任何工程也都能导入它，但是我们的包不完善，需要经常修改，并且我们这个包，也仅仅适用于我们当前的工程，所以这并不是一个理想的选择。</p>
<p>打包的教程在此：<a href="https://python-packaging.readthedocs.org/en/latest/" target="_blank" rel="external">有兴趣者，请戳</a>。</p>
<h4 id="方案2：在每个文件中，修改sys-path">方案2：在每个文件中，修改<code>sys.path</code></h4><p>在每个文件中，都将<code>foo</code>所在的目录的绝对路径添加到<code>sys.path</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sys&#10;sys.path.append(absolute_path)</span><br></pre></td></tr></table></figure>
<p>但这样也存在明显的缺陷，丑陋而繁琐。</p>
<h4 id="方案3：使用相对导入">方案3：使用相对导入</h4><p><strong>这是一个馊主意。</strong></p>
<p>相对导入只在包下才能工作，所以把<code>my_project</code>变成包，然后使用相对导入。</p>
<p>在<code>py_project</code>下加入<code>__init__.py</code>，</p>
<p>修改<code>reference_foo_bar .py</code>的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from ..foo import bar&#10;&#10;if bar.dumb_true():&#10;&#9;print &#34;Hi, we can import foo and use it.&#34;&#10;else :&#10;&#9;print &#34;Hi, we also imported foo but something wrong.&#34;</span><br></pre></td></tr></table></figure>
<p>运行相对导入要掌握正确的姿势，不然，蛋碎。</p>
<p><strong>在new_project的父目录运行：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m new_project.sub_project.reference_foo_bar</span><br></pre></td></tr></table></figure>
<p>运行成功。。。<strong>但这是一个馊主意，我们总不能把我们所有的项目都搞成包吧。</strong>包可以是项目，但项目不是包。</p>
<p>所以，放弃该方法。</p>
<h1 id="参考资料">参考资料</h1><ol>
<li><p>导入原理：<br><a href="http://docs.python-guide.org/en/latest/writing/structure/" target="_blank" rel="external">http://docs.python-guide.org/en/latest/writing/structure/</a></p>
</li>
<li><p>-m 原理</p>
</li>
</ol>
<ul>
<li><a href="http://stackoverflow.com/questions/11536764/attempted-relative-import-in-non-package-even-with-init-py" target="_blank" rel="external">http://stackoverflow.com/questions/11536764/attempted-relative-import-in-non-package-even-with-init-py</a></li>
<li><a href="https://www.quora.com/What-is-the-core-reason-for-this-error-Attempted-relative-import-in-non-package-in-Python" target="_blank" rel="external">https://www.quora.com/What-is-the-core-reason-for-this-error-Attempted-relative-import-in-non-package-in-Python</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Package/">Package</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单元测试/">单元测试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-package-unittest-import-error" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/08/package-unittest-import-error/" class="article-date">
  	<time datetime="2016-01-08T13:51:23.000Z" itemprop="datePublished">2016-01-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/08/package-unittest-import-error/">Python自定义包下不同目录单元测试的导入错误</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>需求驱动学习。</p>
</blockquote>
<h1 id="前言">前言</h1><p>嗯，很绕口的标题</p>
<p>最近的项目需要把编写的工具放到tools目录，把单元测试放到test目录，造成了不同目录下导入（import）的错误。<strong>基础原因很简单，Python无法找到要导入的文件，而解决这个问题的根本方法，是向<code>sys.path</code>中添加搜索路径，如果手动添加，太俗了不是么。</strong></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Package/">Package</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单元测试/">单元测试</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/01/08/package-unittest-import-error/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-never-stop-learning" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/07/never-stop-learning/" class="article-date">
  	<time datetime="2016-01-07T12:40:34.000Z" itemprop="datePublished">2016-01-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/07/never-stop-learning/">不要限制学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>学无止境，莫限制。</p>
</blockquote>
<p>在当初学习Python的时候，对于模块，包并没有细看，当然，书籍上写的也不多，它教会了我：</p>
<ul>
<li>如何使用别人的包、模块。</li>
<li>如何写一个模块，然后在相同的目录下，使用这个模块中的类与函数。</li>
<li>如果不在同目录下，需要将模块在的目录添加到<code>sys.path</code>中。</li>
</ul>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考/">思考</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/01/07/never-stop-learning/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-things-about-github" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/27/things-about-github/" class="article-date">
  	<time datetime="2015-12-27T06:40:01.000Z" itemprop="datePublished">2015-12-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/27/things-about-github/">Github二三事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>总会有些疑问，也总有原因，也必然有解决方案。</p>
</blockquote>
<h2 id="提交者显示unknown">提交者显示unknown</h2><p>明明都是我提交的，怎么显示unkonw commit呢？</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/github-unkonw-commit.png" alt="unknown commit"></p>
<p>原因：本地Git配置的邮箱与Github上面配置的邮箱不一致，具体原因是大小写导致的，本地中有大写字母，而Github上面全为小写。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Github/">Github</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-python-unittest-in-action" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/22/python-unittest-in-action/" class="article-date">
  	<time datetime="2015-12-22T03:09:25.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/22/python-unittest-in-action/">Python单元测试实践</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文主要记录使用Python单元测试时，遇到的问题及解决办法。随着使用的增多，将会遇到更多的问题，与更多的单元测试方法。</p>
</blockquote>
<p>常用的有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertTrue, assertFalse</span><br><span class="line">assertEqual</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单元测试/">单元测试</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/22/python-unittest-in-action/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-think-about-personal-management" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/21/think-about-personal-management/" class="article-date">
  	<time datetime="2015-12-21T01:09:00.000Z" itemprop="datePublished">2015-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/21/think-about-personal-management/">个人管理的思考</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>从时间管理与记录，周计划，日计划，对理想、目标的渴望，每天告诉自己，我设定的目标。一路走来，至今，我突然开始问自己，今天的计划有助于达成我的目标吗？</p>
</blockquote>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考/">思考</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/21/think-about-personal-management/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-think-about-tree" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/21/think-about-tree/" class="article-date">
  	<time datetime="2015-12-21T01:04:23.000Z" itemprop="datePublished">2015-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/21/think-about-tree/">think about tree</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>树，树干长新支，新支又成树干，树枝上还张树叶。树叶产生的营养物质又返回树干，供树干加粗，牢固。</p>
<p>树，可以比作家庭。</p>
<p>一个组织纳新，但老成员是根基。</p>
<p>树叶也可以是泡沫，寒冬来临，叶落，树光秃秃的，那些叶子不落的公司呢，可谓有顽强生命里，华丽的度过寒冬。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考/">思考</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hexo-errors" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/13/hexo-errors/" class="article-date">
  	<time datetime="2015-12-13T04:21:33.000Z" itemprop="datePublished">2015-12-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/13/hexo-errors/">Hexo博客错误汇总</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="博文格式错误">博文格式错误</h1><h2 id="错误1">错误1</h2><p>错误提示如下：</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/13/hexo-errors/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-how-mistake-python-introduction" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/13/how-mistake-python-introduction/" class="article-date">
  	<time datetime="2015-12-13T04:13:33.000Z" itemprop="datePublished">2015-12-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/13/how-mistake-python-introduction/">翻译《Python试错》：前言</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="序言">序言</h1><p>人孰无过，但真正把事情搞糟糕，你还需要一台计算机。<br>——比尔·沃恩</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python试错/">Python试错</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/13/how-mistake-python-introduction/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-back-up-your-blog" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/12/back-up-your-blog/" class="article-date">
  	<time datetime="2015-12-12T08:31:01.000Z" itemprop="datePublished">2015-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/12/back-up-your-blog/">搭好博客勤备份</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前，在搭好博客后我就可是对博客的备份了，备份了配置文件和文章的Markdown文件，以及自己修改的主题。</p>
<p>由于备份的并不是十分勤奋，以至于在我重新做系统后，将备份到Github上的数据Clone到本地后，傻眼了。出现了以下两个大问题：</p>
<ol>
<li>少了几篇文章（一篇文章、笔记可是辛苦了好几天才写出来的呀）。</li>
<li>一些设置没有了，包括博客的自定义主题。</li>
</ol>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blog/">blog</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/12/back-up-your-blog/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Ch6-Exercises-and-Solutions-of-TADM2E" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/12/Ch6-Exercises-and-Solutions-of-TADM2E/" class="article-date">
  	<time datetime="2015-12-12T08:24:02.540Z" itemprop="datePublished">2015-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 class="title">算法设计手册第二版第六章课后习题解答</h1>



<div class="entry">

<blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Weighted-graphs-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Weighted-graphs-TADM2E</a></p>
<p>该页面答案，也是由用户编辑的，不确定是完全的正确。</p>
<h2 id="MST">MST</h2><h3 id="6-2_最短路径与MST">6-2 最短路径与MST</h3><p>题目</p>
<p>Is the path between two vertices in a minimum spanning tree necessarily a shortest path between the two vertices in the full graph? Give a proof or a counterexample.</p>
<p>解答</p>
<p>MST中两点间的路径不是该两点在整个图中的最短路径。</p>
<p><strong>反例：</strong>使用习题5-1的图，使用Kruskal得到的MST是：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-2-1.JPG" alt="习题5-1图"></p>
<a id="more"></a>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-2.JPG" alt="习题5-1图的MST"></p>
<p>路径A-&gt;I：A-&gt;D-&gt;G-&gt;J-&gt;I。路径长度为13，而在整个图中，路劲为A-&gt;I，长度为9。结果已显然。</p>
<h3 id="6-3_最短路径与MST">6-3 最短路径与MST</h3><p>题目</p>
<p>Assume that all edges in the graph have distinct edge weights (i.e., no pair of edges have the same weight). Is the path between a pair of vertices in a minimum spanning tree necessarily a shortest path between the two vertices in the full graph? Give a proof or a counterexample.</p>
<p>解答</p>
<p>否。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-3.JPG" alt="反例图及其MST"></p>
<p>考虑B到D的路径，在图中路径长度为6，而在MST中路径长度为7。</p>
<h3 id="6-4_Prim和Kruskal得到MST是否相同">6-4 Prim和Kruskal得到MST是否相同</h3><p>题目</p>
<p>Can Prim’s and Kruskal’s algorithm yield different minimum spanning trees? Explain why or why not.</p>
<p>解答</p>
<p>在6-1中，Prim与Kruskal就可以产生不同MST。只有当MST本身唯一的时候，由Prim与Kruskal得到的MST才是相同的。</p>
<p>MST唯一的条件：所有边的权值都不相同。</p>
<h3 id="6-5_Prim和Kruskal边权值是否可为负">6-5 Prim和Kruskal边权值是否可为负</h3><p>题目</p>
<p>Does either Prim’s and Kruskal’s algorithm work if there are negative edge weights? Explain why or why not.</p>
<p>解答</p>
<p>思考得到的想法和Wiki页面的想法是类似的，但我还不会严谨的证明。</p>
<p>每条边都会被访问一次，并且只是比较边的大小，既然是仅仅比较大小，那么与正负是没有关系的。不会像Dijkstra那样对边的权值有加法操作，会影响整体的结果。</p>
<h3 id="6-6_添加边，获得新的MST">6-6 添加边，获得新的MST</h3><p>题目</p>
<p>Suppose we are given the minimum spanning tree T of a given graph G (with n vertices and m edges) and a new edge e=(u,v) of weight w that we will add to G. Give an efficient algorithm to find the minimum spanning tree of the graph G+e. Your algorithm should run in O(n) time to receive full credit.</p>
<p>解答</p>
<p>向MST中添加一条边会怎样？对，出现环路。如果增加的边的权值w比从u到v的路径上最大边的权值要小，那么就需要删除掉该最大的边。</p>
<p>从u开始对MST进行DFS可以得到最大的边，时间O(n)。</p>
<p>Google了这道题目，得到了一份考卷，对该问题进行了扩展。题目及答案如下：</p>
<p>Suppose you are given a graph G=(V,E) with edge weights w(e) and a minimum spanning tree T of G. Now, suppose a new edge {u,v} is added to G. Describe (in words) a method for determining if T is still a minimum spanning tree for G.</p>
<p><em>Examine the path in T from u to v. If any vertex on this path has weight larger than that of the new edge, then T is no longer an MST. We can modify T to obtain a new MST by removing the max weight edge on this path and replacing it with the new edge.</em></p>
<p>Explain how your method can be implemented to run in O(n) time if both G and T are provided as instances of the wgraph data structure.</p>
<p><em>Using the wgraph for T, we can do a recursive tree traversal in T, starting at vertex u. Once the traversal reaches v, we “unwind” the recursion, and as we do so, we look for the max weight edge along the u,v path. The runtime for a tree traversal is O(n) and the required changes to T can be done in constant time.</em></p>
<p>Suppose that instead of a single edge, you are given a set of k new edges to add to G. For small enough k it makes sense to apply your algorithm repeatedly in order to update the MST, but if k is “too large”, it’s more efficient to re-compute the MST from scratch. How big does k have to be (as a function of m and n) in order for this to be a better choice? Assume that the MST is computed using Prim’s algorithm with a d-heap, where d=2.</p>
<p><em>When d=2, the running time for Prim’s algorithm is O(m log n), so if kn grows faster than this, it makes sense to recompute from scratch. So, if k&gt;(m/n) log n, it makes sense to recompute the MST.</em></p>
<h3 id="6-7_改变权值，MST是否改变，最短路径是否改变">6-7 改变权值，MST是否改变，最短路径是否改变</h3><p>题目</p>
<p>(a) Let T be a minimum spanning tree of a weighted graph G. Construct a new graph G′ by adding a weight of k to every edge of G. Do the edges of T form a minimum spanning tree of G′? Prove the statement or give a counterexample. </p>
<p>(b) Let P={s,…,t} describe a shortest weighted path between vertices s and t of a weighted graph G. Construct a new graph G′ by adding a weight of k to every edge of G. Does P describe a shortest path from s to t in G′? Prove the statement or give a counterexample.</p>
<p>解答</p>
<p>(a) 是的。</p>
<p>6-5中提到了，MST与权值的具体数值无关，只要能比较边的大小即可。每条边的权值都增加了k，它们依然是可以比较大小的，并且它们的相对大小并没有变化，因此T会是G’的一个MST。</p>
<p><em>这点我同答案wiki页面是不同的，那里面的回答是“可能是”。</em></p>
<p>(b) 答案不确定。</p>
<p>Dijkstra算法：只能处理非负权值的边。<br>Floyd-Warshall算法：能处理包含负边的图，但不能处理存在负边构成环的图。</p>
<ol>
<li>只要不存在负权值的边，答案是肯定的，依然是P。</li>
<li>存在负边时，我不确定。</li>
</ol>
<h3 id="6-8_已最小的代价改变MST">6-8 已最小的代价改变MST</h3><p>题目</p>
<p>Devise and analyze an algorithm that takes a weighted graph G and finds the smallest change in the cost to a non-MST edge that would cause a change in the minimum spanning tree of G. Your algorithm must be correct and run in polynomial time.</p>
<p>解答</p>
<p>polynomial time：2<sup>O(log n)</sup>, eg. n, nlogn, n<sup>10</sup>。</p>
<p>什么样的边会影响最小生成树？</p>
<p>在图的某个环中，除了这条边e，其他边都是MST中的边，那么只要e小于其中任何一条边的值就可以改变MST。</p>
<p>再详细一点，边e是环中最大的边，边x是该环剩下的边在MST中最大的边。只要使得边e的值略小于边x的值即可，这样可以保证最小的代价改变MST。</p>
<p>以6-2中的图为例，边(I,G)、(E,G)是符合条件的，减1即可，其他非MST边减的都大于1才能改变MST。</p>
<p>假设n个点，m条边，则非MST边有(m-n+1)，根据MST找到每条边所在换，并计算最小变化需要O(n)，则时间复杂度为O(n(m-n))。</p>
<p><em>我相信这不是最好的解决方案。</em></p>
<h3 id="6-9_最小连通子集">6-9 最小连通子集</h3><p>题目</p>
<p>Consider the problem of finding a minimum weight connected subset T of edges from a weighted connected graph G. The weight of T is the sum of all the edge weights in T.</p>
<p>(a) Why is this problem not just the minimum spanning tree problem? Hint: think negative weight edges.<br>(b) Give an efficient algorithm to compute the minimum weight connected subset T.</p>
<p>解答</p>
<p>若保证子图是连通的，那么T至少包含MST。向MST上添加一条边会怎样？</p>
<ol>
<li>正边：增加T的权值，不要。</li>
<li>0：不改变权值，不要。</li>
<li>负边：减小T的权值，要。</li>
</ol>
<p>因此，所有的负边都不能放过。问题来了，是先生成MST，再把所有的负边添加到MST中构成T，还是先得到所有的负边，再使用Kruskal让图连通得到T呢？</p>
<p>无论哪种方法，<strong>最后T的权值都是一样的</strong>。</p>
<ol>
<li>前面证明了，在MST的边与非MST边e构成的环中，边e之所以不在MST中，就是因为它是环里面最大的，虽然现在边e的权值是负的，但仍然是最大的，因此把e添加进来，不会造成要删除其他MST边。最后得到的T的权值必然是最小的。</li>
<li>先得所有负边，在Kruskal得到的T的权值必然也是最小的，因为它一直都在选最小的边。</li>
</ol>
<h3 id="6-10_feedback-edge_set">6-10 feedback-edge set</h3><p>题目</p>
<p>Let G=(V,E) be an undirected graph. A set F⊆E of edges is called a feedback-edge set if every cycle of G has at least one edge in F.</p>
<p>(a) Suppose that G is unweighted. Design an efficient algorithm to find a minimum-size feedback-edge set.<br>(b) Suppose that G is a weighted undirected graph with positive edge weights. Design an efficient algorithm to find a minimum-weight feedback-edge set.</p>
<p>解答</p>
<p>(a)</p>
<ol>
<li>记录每条边属于哪些环。</li>
<li>拥有最多环的那条边e加入F。</li>
<li>更新每条边，删除它们e中拥有的边，此时e拥有的边变为了0个。</li>
<li>重复2-3，直到所有边不拥有环。</li>
</ol>
<p>时间复杂度嘛，看样子还是不小的。要找到么一个环，然后标记每条边在几个环内，还要排序，删除，不是一个高效的方案。</p>
<p>(b)</p>
<h2 id="并查集">并查集</h2><h3 id="6-12_设计并查集及算法">6-12 设计并查集及算法</h3><p>题目</p>
<p>Devise an efficient data structure to handle the following operations on a weighted directed graph:</p>
<p>(a) Merge two given components.<br>(b) Locate which component contains a given vertex v.<br>(c) Retrieve a minimum edge from a given component.</p>
<p>解答</p>
<p>在课本的并查集操作，得到的并查集是这样的。<br><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-12 b.png" alt="原始并查集结果"></p>
<p>要想确定两个顶点在不在一个集合内，需要找到代表这个集合的根节点，find的效率并不高，他需要多次递归才能得到根节点。</p>
<p>如果能提高find的效率，并查集的操作也将提高很多。常见的做法是，<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="external">路径压缩</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(set_union *s, <span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;p[x] != x)</span><br><span class="line">        s-&gt;p[x] = find(s, s-&gt;p[x]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s-&gt;p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径">最短路径</h2><h3 id="6-14_单目的最短路径">6-14 单目的最短路径</h3><p>题目</p>
<p>The <em>single-destination shortest path</em> problem for a <strong>directed graph</strong> seeks the shortest path from every vertex to a specified vertex v. Give an efficient algorithm to solve the single-destination shortest paths problem.</p>
<p>解答</p>
<p>如果是无向图的话，执行Dijkstra算法即可，然后倒转所有的路径。但是，题目指明是基于有向图的问题。</p>
<p>另外，Kruskal算法是All-Pairs最短路径，如果想到的算法时间复杂度大于O(n<sup>3</sup>)，那还不如直接使用Kruskal。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-14.png" alt="6-14图"></p>
<p>如上图,假设要求从s到t的最短路径，并且已经求得c1,c2,c3到t的最短路径，那么s到t的最短路径应当为 <code>W[s,t] = min(W[s,c1]+W[c1,t], W[s,c2]+W[c2,t], W[s,c3]+W[c3,t])</code>。</p>
<p>自然而然，应当想到了递归解法。Oh，接下来貌似你要考虑一下这些问题：</p>
<ol>
<li>从哪个点开始递归，可以向dfs中那样使用for循环</li>
<li>怎么处理环</li>
<li>。。。</li>
</ol>
<p>再回首想想：<strong>图的解决方案，是对图进行建模，使用已有的算法，而不是设计新的算法</strong></p>
<p>使用Dijkstra算法。反向建立图G’ = (V’,E’), V = V’, {u,v}∈E, {v,u}属于E’。对G’使用Dijkstra算法得到从v到任意节点的最短路径，倒转所有路径即从所有节点到v的最短路径。</p>
<h3 id="6-16_MST与SPT">6-16 MST与SPT</h3><p>题目</p>
<p>Answer all of the following:</p>
<p>(a) Give an example of a weighted connected graph G=(V,E) and a vertex v, such that the minimum spanning tree of G is the same as the shortest-path spanning tree rooted at v.<br>(b) Give an example of a weighted connected directed graph G=(V,E) and a vertex v, such that the <em>minimum-cost spanning tree</em> of G is very different from the shortest-path spanning tree rooted at v.<br>(c) Can the two trees be completely disjointed?</p>
<p>解答</p>
<p>(a) 图G、MST、SP构成的树都是下图：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-16 a.png" alt="Ex 6-16 a"></p>
<p>(b) minimum-cost spanning tree就是MST，看到这个刚开始还觉得这是不是一个新东西。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-16 b.png" alt="Ex 6-16 b"></p>
<p>(c) What is ‘completely disjointed’?</p>
<h3 id="6-17_MST的边与SP的边">6-17 MST的边与SP的边</h3><p>题目</p>
<p>Either prove the following or give a counterexample:</p>
<p>(a) Is the path between a pair of vertices in a minimum spanning tree of an undirected graph necessarily the shortest (minimum weight) path?<br>(b) Suppose that the minimum spanning tree of the graph is unique. Is the path between a pair of vertices in a minimum spanning tree of an undirected graph necessarily the shortest (minimum weight) path?</p>
<p>解答</p>
<p>(a) 否。见上题(b)。边(A,C)就不在最短路径中。</p>
<p>(b) 否。见上题(b)。图G的MST是唯一的，那么现在又回到了题(a)。</p>
<h3 id="6-18_顶点有权值">6-18 顶点有权值</h3><p>题目</p>
<p>In certain graph problems, vertices have can have weights instead of or in addition to the weights of edges. Let Cv be the cost of vertex v, and C(x,y) the cost of the edge (x,y). This problem is concerned with finding the cheapest path between vertices a and b in a graph G. The cost of a path is the sum of the costs of the edges and vertices encountered on the path.</p>
<p>(a) Suppose that each edge in the graph has a weight of zero (while non-edges have a cost of ∞). Assume that Cv=1 for all vertices 1≤v≤n (i.e., all vertices have the same cost). Give an efficient algorithm to find the cheapest path from a to b and its time complexity.<br>(b) Now suppose that the vertex costs are not constant (but are all positive) and the edge costs remain as above. Give an efficient algorithm to find the cheapest path from a to b and its time complexity.<br>(c) Now suppose that both the edge and vertex costs are not constant (but are all positive). Give an efficient algorithm to find the cheapest path from a to b and its time complexity.</p>
<p>解答</p>
<blockquote>
<p>6.3.1 Stop and Think<br>Set the weight of each directed edge{i,j} in the input graph to the cost of vertex j. Dijkstra’s algorithm now does the job.</p>
</blockquote>
<p>我的解决方案：</p>
<p>设边{i,j}的权值为W[i,j]。则将其改为W[i,j] = W[i,j] + C<sub>j</sub>，然后使用Dijkstra。</p>
<p>W[i,j]初始化：<br>(a) W[i,j] = 0.<br>(b) W[i,j] = k(常数).<br>(c) W[i,j] 原本值。</p>
<h3 id="6-19_最小有向环">6-19 最小有向环</h3><p>题目</p>
<p>Let G be a weighted directed graph with n vertices and m edges, where all edges have positive weight. A directed cycle is a directed path that starts and ends at the same vertex and contains at least one edge. Give an O(n<sup>3</sup>) algorithm to find a directed cycle in G of minimum total weight. Partial credit will be given for an O(n<sup>2</sup>m) algorithm.</p>
<p>解答</p>
<p>如果对Floyd的过程比较了解，这个真的很简单，因为Floyd得到的是All-pairs，包括了i到i的最短距离，即<code>g-&gt;weight[i][i]</code>。遍历便可的最小值。</p>
<p>我在做Floyd的时候，对有向图做了测试，<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/floyd.c" target="_blank" rel="external">github传送门</a>。</p>
<h3 id="6-20_最长路径">6-20 最长路径</h3><p>题目</p>
<p>Can we modify Dijkstra’s algorithm to solve the single-source longest path problem by changing {\em minimum} to maximum? If so, then prove your algorithm correct. If not, then provide a counterexample.</p>
<p>解答</p>
<p>Longest path is basically the <em>Hamiltonian Cycle problem</em> or the <em>Traveling Salesman Problem</em>, and it is NP-hard. So no, and if you find a way, then P=NP.</p>
<p>The existence or non-existence of an algorithm to find the largest path, in polynomial time, is essentially part of the largest open problem in all of CS (and probably in math).</p>
<p><a href="http://cs.stackexchange.com/questions/17980/is-it-possible-to-modify-dijkstra-algorithm-in-order-to-get-the-longest-path" target="_blank" rel="external">参考资料1</a><br><a href="http://cs.stackexchange.com/questions/10732/how-to-prove-np-hardness-of-a-longest-path-problem" target="_blank" rel="external">参考资料2</a></p>
<h3 id="6-21_SSSP_线性时间">6-21 SSSP 线性时间</h3><p>题目</p>
<p>Let G=(V,E) be a weighted acyclic directed graph with possibly negative edge weights. Design a linear-time algorithm to solve the single-source shortest-path problem from a given source v.</p>
<p>解答</p>
<ol>
<li><p>使用拓扑排序：O(E+V)<br><a href="http://en.wikipedia.org/wiki/Topological_sorting#Application_to_shortest_path_finding" target="_blank" rel="external">参考资料</a></p>
</li>
<li><p>Google: linear-time algorithm to solve the single-source shortest-path, 会搜到几篇论文，解决方案是修改Dijkstra算法。</p>
</li>
</ol>
<h3 id="6-22_长度为k的最短路径">6-22 长度为k的最短路径</h3><p>题目</p>
<p>Let G=(V,E) be a directed weighted graph such that all the weights are positive. Let v and w be two vertices in G and k≤|V| be an integer. Design an algorithm to find the shortest path from v to w that contains exactly k edges. Note that the path need not be simple.</p>
<p>解答</p>
<p>注意最后一句：意味着图可能存在环的，并且路径中也可以存在环。</p>
<p>比如图为：A&lt;-&gt;B，v=A, w=B.<br>k=1时，A-&gt;B;<br>k=2时，不存在。<br>k=3时，A-&gt;B-&gt;A-&gt;B。</p>

      
    </div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Ch7-Exercises-and-Solutions-of-TADM2E" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/12/Ch7-Exercises-and-Solutions-of-TADM2E/" class="article-date">
  	<time datetime="2015-12-12T07:43:28.234Z" itemprop="datePublished">2015-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>算法设计手册第二版第七章课后习题解答</h1>
    <div class="entry">
      

        
        <blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Search-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Search-TADM2E</a></p>
<p>该页面答案，也是由用户编辑的，不确定是完全的正确。</p>
<h2 id="Backtracking">Backtracking</h2><h3 id="7-1_permutations">7-1 permutations</h3><p>题目</p>
<p>A derangement is a permutation p of {1,…,n} such that no item is in its proper position, i.e. pi≠i for all 1≤i≤n. derangement Write an efficient backtracking program with pruning that constructs all the derangements of n items.</p>
<p>解答</p>
<p>剪枝就是构建合适的候选者。只需增加一个限制条件<code>i != k</code>。<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/7.11/7_1_permutations.c" target="_blank" rel="external">完整代码</a>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> construct_candidates(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> c[], <span class="keyword">int</span> *ncandidates)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">bool</span> in_perm[NMAX];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;NMAX; ++i) in_perm[i] = <span class="literal">FALSE</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;k; ++i)  in_perm[a[i]] = <span class="literal">TRUE</span>;</span><br><span class="line">  *ncandidates = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i != k &amp;&amp; in_perm[i] == <span class="literal">FALSE</span>) <span class="comment">// pruning</span></span><br><span class="line">      c[(*ncandidates)++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2_Multisets">7-2 Multisets</h3><p>题目</p>
<p>Multisets are allowed to have repeated elements. A multiset of n items may thus have fewer than n! distinct permutations. For example, {1,1,2,2} has only six different permutations: {1,1,2,2}, {1,2,1,2}, {1,2,2,1}, {2,1,1,2}, {2,1,2,1}, and {2,2,1,1}. multiset Design and implement an efficient algorithm for constructing all permutations of a multiset.</p>
<p>解答</p>
<p>在每次选取候选者的时候，重复的候选者，只选择一个，就不会出现同一个数字在同一个位置，出现多次。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mulset[NMAX];            <span class="comment">// Multisets</span></span><br><span class="line">a[];                     <span class="comment">// save the indexes of the number in mulset</span></span><br><span class="line"><span class="keyword">void</span> construct_candidates(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> c[], <span class="keyword">int</span> *ncandidates)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">bool</span> in_perm[NMAX];   <span class="comment">// save the indexes of the number in mulset</span></span><br><span class="line">  <span class="keyword">int</span> uniset[NMAX];     <span class="comment">// save the first indexes of a number in mulset</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;NMAX; ++i) in_perm[i] = <span class="literal">FALSE</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;k; ++i)  in_perm[a[i]] = <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">  get_unique_set(in_perm, uniset); </span><br><span class="line"></span><br><span class="line">  *ncandidates = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i != k &amp;&amp; uniset[i] == <span class="literal">FALSE</span>) <span class="comment">// pruning</span></span><br><span class="line">      c[(*ncandidates)++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3_图的同构">7-3 图的同构</h3><p>题目</p>
<p>Design and implement an algorithm for testing whether two graphs are isomorphic to each other. The graph isomorphism problem is discussed in graph-isomorphism. With proper pruning, graphs on hundreds of vertices can be tested reliably.</p>
<p>解答</p>
<p>NP问题。</p>
<p>方法就是进行验证。</p>
<p>以无向图举例。</p>
<ol>
<li>顶点数量相同。</li>
<li>在图G中任选一点，依次与图H中的点进行匹配。</li>
<li>那么总的配对方式供NxN个。</li>
<li>验证方式是：图G中有的边，图H中也有，图H中有的边图G中也有。</li>
</ol>
<p>剪枝：仅将H中与G中当前顶点度相同的顶点加入到候选者列表。</p>
<h3 id="7-4">7-4</h3><p>题目</p>
<p>Anagrams are rearrangements of the letters of a word or phrase into a different word or phrase. Sometimes the results are quite striking. For example, “MANY VOTED BUSH RETIRED” is an anagram of “TUESDAY NOVEMBER THIRD”, which correctly predicted the result of the 1992 U.S. presidential election. Design and implement an algorithm for finding anagrams using combinatorial search and a dictionary.</p>
<p>解答</p>
<ol>
<li>根据输入字符串，拆解得到一个字符池。池中字母保持字典顺序。</li>
<li>按照课本构造子集的方式，得到一个子集，即一个“单词”，判断该单词在不在词典中？<br> 2.1 在，则从剩下的字符池继续构建单词，直到池为空，得到一个solution；<br> 2.2 否，构建下一个单词。</li>
</ol>

      
    </div>
    
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Well-Prepared-For-Campus-Recruit" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/01/Well-Prepared-For-Campus-Recruit/" class="article-date">
  	<time datetime="2015-12-01T10:32:13.000Z" itemprop="datePublished">2015-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/01/Well-Prepared-For-Campus-Recruit/">校园招聘哪些事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>打算分为以下几个方面记录一些校园资料。虽然大部分都被我存到笔记软件中，以后就放这里吧。笔记软件里面的东西越来越多，尽管已经为每篇笔记设置了标签和分类，但依然有点冗肿了，并且搜索有点慢。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/招聘/">招聘</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/01/Well-Prepared-For-Campus-Recruit/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-How-to-Select-Programming-Language-md" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/30/How-to-Select-Programming-Language-md/" class="article-date">
  	<time datetime="2015-11-29T16:00:00.000Z" itemprop="datePublished">2015-11-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/30/How-to-Select-Programming-Language-md/">如何选择编程语言</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>随着认识的积累，对编程语言的看法也在改变。</p>
</blockquote>
<p>以下内容，纯吐槽。</p>
<h1 id="C，C++，Java">C，C++，Java</h1><p>本科的时候只接触了C，C++，Java，那就先吐槽一下他们吧。</p>
<p>期初很狭隘的认为学习一两个编程语言就足够了，这样就可以做许多东西了，学那么多编程语言有必要吗？</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程语言/">编程语言</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/11/30/How-to-Select-Programming-Language-md/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 随风
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>