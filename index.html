<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>随风</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="屌丝程序员的自留地#为搜索引擎留的">
<meta property="og:type" content="website">
<meta property="og:title" content="随风">
<meta property="og:url" content="http://shitaibin.github.io/index.html">
<meta property="og:site_name" content="随风">
<meta property="og:description" content="屌丝程序员的自留地#为搜索引擎留的">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="随风">
<meta name="twitter:description" content="屌丝程序员的自留地#为搜索引擎留的">
  
    <link rel="alternative" href="/atom.xml" title="随风" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xixtr.com1.z0.glb.clouddn.com/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">随风</a></h1>
		</hgroup>

		
		<p class="header-subtitle">随风而起，随风而散</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Shitaibin" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Github-Pages/" style="font-size: 10px;">Github Pages</a> <a href="/tags/Hexo/" style="font-size: 20px;">Hexo</a> <a href="/tags/Package/" style="font-size: 13.33px;">Package</a> <a href="/tags/Python/" style="font-size: 16.67px;">Python</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/TADM/" style="font-size: 13.33px;">TADM</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/malloc/" style="font-size: 10px;">malloc</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/单元测试/" style="font-size: 16.67px;">单元测试</a> <a href="/tags/图论/" style="font-size: 10px;">图论</a> <a href="/tags/待办/" style="font-size: 10px;">待办</a> <a href="/tags/思考/" style="font-size: 13.33px;">思考</a> <a href="/tags/招聘/" style="font-size: 10px;">招聘</a> <a href="/tags/排序/" style="font-size: 10px;">排序</a> <a href="/tags/搜索/" style="font-size: 13.33px;">搜索</a> <a href="/tags/数据挖掘/" style="font-size: 10px;">数据挖掘</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/特征/" style="font-size: 10px;">特征</a> <a href="/tags/编程语言/" style="font-size: 10px;">编程语言</a> <a href="/tags/面试/" style="font-size: 13.33px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">随风</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xixtr.com1.z0.glb.clouddn.com/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">随风</h1>
			</hgroup>
			
			<p class="header-subtitle">随风而起，随风而散</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Shitaibin" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-a-malloc-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/14/a-malloc-tutorial/" class="article-date">
  	<time datetime="2016-04-14T11:05:37.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/14/a-malloc-tutorial/">malloc的故事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>读了张洋的《如何实现一个malloc》和Marwan Burlle的《A Malloc Turorial》，张洋的博文是对Marwan Burlle的理解、翻译和补充，缺失了一些细节。但读了张洋的文章后，再读《A Malloc Turorial》会快很多。</p>
<p>#A Malloc Tutorial</p>
<h3 id="讲了什么">讲了什么</h3><ol>
<li>什么是malloc</li>
<li>堆的内存模型</li>
<li>如何通过系统调用操纵堆</li>
<li>什么是块、块的数据结构</li>
<li>结构体的本质（虽然变量data属于结构体，但只是想获取数据区的指针，而数据区不属于meta结构体）</li>
<li>如何实现内存对齐</li>
<li>基本的堆管理需要哪些功能/函数</li>
<li>如何创建、选择、分割块</li>
<li>碎片整理（融合块）</li>
<li>free要做什么，如何实现</li>
<li>如何实现calloc</li>
<li>何时把块“还给系统”</li>
<li>realloc的原理，及优化</li>
</ol>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/malloc/">malloc</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/04/14/a-malloc-tutorial/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-learn-dynamic-programming" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/04/learn-dynamic-programming/" class="article-date">
  	<time datetime="2016-04-04T14:19:44.000Z" itemprop="datePublished">2016-04-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/04/learn-dynamic-programming/">动态规划</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>动态规划一直以来，算是一个弱点，前几腾讯的实习生笔试有道区间DP的题目，当时只能暴力的使用了递归，存在大量的重复计算，时间复杂度会达到O(N^2)。所以今日，查资料，从基础学习DP。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态规划/">动态规划</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/04/04/learn-dynamic-programming/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Ch7-Exercises-and-Solutions-of-TADM2E" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/24/Ch7-Exercises-and-Solutions-of-TADM2E/" class="article-date">
  	<time datetime="2016-03-24T04:51:38.324Z" itemprop="datePublished">2016-03-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>算法设计手册第二版第七章课后习题解答</h1>
    <div class="entry">
      

        
        <blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Search-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Search-TADM2E</a></p>
<p>该页面答案，也是由用户编辑的，不确定是完全的正确。</p>
<h2 id="Backtracking">Backtracking</h2><h3 id="7-1_permutations">7-1 permutations</h3><p>题目</p>
<p>A derangement is a permutation p of {1,…,n} such that no item is in its proper position, i.e. pi≠i for all 1≤i≤n. derangement Write an efficient backtracking program with pruning that constructs all the derangements of n items.</p>
<p>解答</p>
<p>剪枝就是构建合适的候选者。只需增加一个限制条件<code>i != k</code>。<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/7.11/7_1_permutations.c" target="_blank" rel="external">完整代码</a>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> construct_candidates(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> c[], <span class="keyword">int</span> *ncandidates)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">bool</span> in_perm[NMAX];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;NMAX; ++i) in_perm[i] = <span class="literal">FALSE</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;k; ++i)  in_perm[a[i]] = <span class="literal">TRUE</span>;</span><br><span class="line">  *ncandidates = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i != k &amp;&amp; in_perm[i] == <span class="literal">FALSE</span>) <span class="comment">// pruning</span></span><br><span class="line">      c[(*ncandidates)++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2_Multisets">7-2 Multisets</h3><p>题目</p>
<p>Multisets are allowed to have repeated elements. A multiset of n items may thus have fewer than n! distinct permutations. For example, {1,1,2,2} has only six different permutations: {1,1,2,2}, {1,2,1,2}, {1,2,2,1}, {2,1,1,2}, {2,1,2,1}, and {2,2,1,1}. multiset Design and implement an efficient algorithm for constructing all permutations of a multiset.</p>
<p>解答</p>
<p>在每次选取候选者的时候，重复的候选者，只选择一个，就不会出现同一个数字在同一个位置，出现多次。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mulset[NMAX];            <span class="comment">// Multisets</span></span><br><span class="line">a[];                     <span class="comment">// save the indexes of the number in mulset</span></span><br><span class="line"><span class="keyword">void</span> construct_candidates(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> c[], <span class="keyword">int</span> *ncandidates)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">bool</span> in_perm[NMAX];   <span class="comment">// save the indexes of the number in mulset</span></span><br><span class="line">  <span class="keyword">int</span> uniset[NMAX];     <span class="comment">// save the first indexes of a number in mulset</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;NMAX; ++i) in_perm[i] = <span class="literal">FALSE</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;k; ++i)  in_perm[a[i]] = <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">  get_unique_set(in_perm, uniset); </span><br><span class="line"></span><br><span class="line">  *ncandidates = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i != k &amp;&amp; uniset[i] == <span class="literal">FALSE</span>) <span class="comment">// pruning</span></span><br><span class="line">      c[(*ncandidates)++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3_图的同构">7-3 图的同构</h3><p>题目</p>
<p>Design and implement an algorithm for testing whether two graphs are isomorphic to each other. The graph isomorphism problem is discussed in graph-isomorphism. With proper pruning, graphs on hundreds of vertices can be tested reliably.</p>
<p>解答</p>
<p>NP问题。</p>
<p>方法就是进行验证。</p>
<p>以无向图举例。</p>
<ol>
<li>顶点数量相同。</li>
<li>在图G中任选一点，依次与图H中的点进行匹配。</li>
<li>那么总的配对方式供NxN个。</li>
<li>验证方式是：图G中有的边，图H中也有，图H中有的边图G中也有。</li>
</ol>
<p>剪枝：仅将H中与G中当前顶点度相同的顶点加入到候选者列表。</p>
<h3 id="7-4">7-4</h3><p>题目</p>
<p>Anagrams are rearrangements of the letters of a word or phrase into a different word or phrase. Sometimes the results are quite striking. For example, “MANY VOTED BUSH RETIRED” is an anagram of “TUESDAY NOVEMBER THIRD”, which correctly predicted the result of the 1992 U.S. presidential election. Design and implement an algorithm for finding anagrams using combinatorial search and a dictionary.</p>
<p>解答</p>
<ol>
<li>根据输入字符串，拆解得到一个字符池。池中字母保持字典顺序。</li>
<li>按照课本构造子集的方式，得到一个子集，即一个“单词”，判断该单词在不在词典中？<br> 2.1 在，则从剩下的字符池继续构建单词，直到池为空，得到一个solution；<br> 2.2 否，构建下一个单词。</li>
</ol>

      
    </div>
    
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Ch6-Exercises-and-Solutions-of-TADM2E" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/24/Ch6-Exercises-and-Solutions-of-TADM2E/" class="article-date">
  	<time datetime="2016-03-24T04:51:38.323Z" itemprop="datePublished">2016-03-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h1 class="title">算法设计手册第二版第六章课后习题解答</h1>



<div class="entry">

<blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Weighted-graphs-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Weighted-graphs-TADM2E</a></p>
<p>该页面答案，也是由用户编辑的，不确定是完全的正确。</p>
<h2 id="MST">MST</h2><h3 id="6-2_最短路径与MST">6-2 最短路径与MST</h3><p>题目</p>
<p>Is the path between two vertices in a minimum spanning tree necessarily a shortest path between the two vertices in the full graph? Give a proof or a counterexample.</p>
<p>解答</p>
<p>MST中两点间的路径不是该两点在整个图中的最短路径。</p>
<p><strong>反例：</strong>使用习题5-1的图，使用Kruskal得到的MST是：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-2-1.JPG" alt="习题5-1图"></p>
<a id="more"></a>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-2.JPG" alt="习题5-1图的MST"></p>
<p>路径A-&gt;I：A-&gt;D-&gt;G-&gt;J-&gt;I。路径长度为13，而在整个图中，路劲为A-&gt;I，长度为9。结果已显然。</p>
<h3 id="6-3_最短路径与MST">6-3 最短路径与MST</h3><p>题目</p>
<p>Assume that all edges in the graph have distinct edge weights (i.e., no pair of edges have the same weight). Is the path between a pair of vertices in a minimum spanning tree necessarily a shortest path between the two vertices in the full graph? Give a proof or a counterexample.</p>
<p>解答</p>
<p>否。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-3.JPG" alt="反例图及其MST"></p>
<p>考虑B到D的路径，在图中路径长度为6，而在MST中路径长度为7。</p>
<h3 id="6-4_Prim和Kruskal得到MST是否相同">6-4 Prim和Kruskal得到MST是否相同</h3><p>题目</p>
<p>Can Prim’s and Kruskal’s algorithm yield different minimum spanning trees? Explain why or why not.</p>
<p>解答</p>
<p>在6-1中，Prim与Kruskal就可以产生不同MST。只有当MST本身唯一的时候，由Prim与Kruskal得到的MST才是相同的。</p>
<p>MST唯一的条件：所有边的权值都不相同。</p>
<h3 id="6-5_Prim和Kruskal边权值是否可为负">6-5 Prim和Kruskal边权值是否可为负</h3><p>题目</p>
<p>Does either Prim’s and Kruskal’s algorithm work if there are negative edge weights? Explain why or why not.</p>
<p>解答</p>
<p>思考得到的想法和Wiki页面的想法是类似的，但我还不会严谨的证明。</p>
<p>每条边都会被访问一次，并且只是比较边的大小，既然是仅仅比较大小，那么与正负是没有关系的。不会像Dijkstra那样对边的权值有加法操作，会影响整体的结果。</p>
<h3 id="6-6_添加边，获得新的MST">6-6 添加边，获得新的MST</h3><p>题目</p>
<p>Suppose we are given the minimum spanning tree T of a given graph G (with n vertices and m edges) and a new edge e=(u,v) of weight w that we will add to G. Give an efficient algorithm to find the minimum spanning tree of the graph G+e. Your algorithm should run in O(n) time to receive full credit.</p>
<p>解答</p>
<p>向MST中添加一条边会怎样？对，出现环路。如果增加的边的权值w比从u到v的路径上最大边的权值要小，那么就需要删除掉该最大的边。</p>
<p>从u开始对MST进行DFS可以得到最大的边，时间O(n)。</p>
<p>Google了这道题目，得到了一份考卷，对该问题进行了扩展。题目及答案如下：</p>
<p>Suppose you are given a graph G=(V,E) with edge weights w(e) and a minimum spanning tree T of G. Now, suppose a new edge {u,v} is added to G. Describe (in words) a method for determining if T is still a minimum spanning tree for G.</p>
<p><em>Examine the path in T from u to v. If any vertex on this path has weight larger than that of the new edge, then T is no longer an MST. We can modify T to obtain a new MST by removing the max weight edge on this path and replacing it with the new edge.</em></p>
<p>Explain how your method can be implemented to run in O(n) time if both G and T are provided as instances of the wgraph data structure.</p>
<p><em>Using the wgraph for T, we can do a recursive tree traversal in T, starting at vertex u. Once the traversal reaches v, we “unwind” the recursion, and as we do so, we look for the max weight edge along the u,v path. The runtime for a tree traversal is O(n) and the required changes to T can be done in constant time.</em></p>
<p>Suppose that instead of a single edge, you are given a set of k new edges to add to G. For small enough k it makes sense to apply your algorithm repeatedly in order to update the MST, but if k is “too large”, it’s more efficient to re-compute the MST from scratch. How big does k have to be (as a function of m and n) in order for this to be a better choice? Assume that the MST is computed using Prim’s algorithm with a d-heap, where d=2.</p>
<p><em>When d=2, the running time for Prim’s algorithm is O(m log n), so if kn grows faster than this, it makes sense to recompute from scratch. So, if k&gt;(m/n) log n, it makes sense to recompute the MST.</em></p>
<h3 id="6-7_改变权值，MST是否改变，最短路径是否改变">6-7 改变权值，MST是否改变，最短路径是否改变</h3><p>题目</p>
<p>(a) Let T be a minimum spanning tree of a weighted graph G. Construct a new graph G′ by adding a weight of k to every edge of G. Do the edges of T form a minimum spanning tree of G′? Prove the statement or give a counterexample. </p>
<p>(b) Let P={s,…,t} describe a shortest weighted path between vertices s and t of a weighted graph G. Construct a new graph G′ by adding a weight of k to every edge of G. Does P describe a shortest path from s to t in G′? Prove the statement or give a counterexample.</p>
<p>解答</p>
<p>(a) 是的。</p>
<p>6-5中提到了，MST与权值的具体数值无关，只要能比较边的大小即可。每条边的权值都增加了k，它们依然是可以比较大小的，并且它们的相对大小并没有变化，因此T会是G’的一个MST。</p>
<p><em>这点我同答案wiki页面是不同的，那里面的回答是“可能是”。</em></p>
<p>(b) 答案不确定。</p>
<p>Dijkstra算法：只能处理非负权值的边。<br>Floyd-Warshall算法：能处理包含负边的图，但不能处理存在负边构成环的图。</p>
<ol>
<li>只要不存在负权值的边，答案是肯定的，依然是P。</li>
<li>存在负边时，我不确定。</li>
</ol>
<h3 id="6-8_已最小的代价改变MST">6-8 已最小的代价改变MST</h3><p>题目</p>
<p>Devise and analyze an algorithm that takes a weighted graph G and finds the smallest change in the cost to a non-MST edge that would cause a change in the minimum spanning tree of G. Your algorithm must be correct and run in polynomial time.</p>
<p>解答</p>
<p>polynomial time：2<sup>O(log n)</sup>, eg. n, nlogn, n<sup>10</sup>。</p>
<p>什么样的边会影响最小生成树？</p>
<p>在图的某个环中，除了这条边e，其他边都是MST中的边，那么只要e小于其中任何一条边的值就可以改变MST。</p>
<p>再详细一点，边e是环中最大的边，边x是该环剩下的边在MST中最大的边。只要使得边e的值略小于边x的值即可，这样可以保证最小的代价改变MST。</p>
<p>以6-2中的图为例，边(I,G)、(E,G)是符合条件的，减1即可，其他非MST边减的都大于1才能改变MST。</p>
<p>假设n个点，m条边，则非MST边有(m-n+1)，根据MST找到每条边所在换，并计算最小变化需要O(n)，则时间复杂度为O(n(m-n))。</p>
<p><em>我相信这不是最好的解决方案。</em></p>
<h3 id="6-9_最小连通子集">6-9 最小连通子集</h3><p>题目</p>
<p>Consider the problem of finding a minimum weight connected subset T of edges from a weighted connected graph G. The weight of T is the sum of all the edge weights in T.</p>
<p>(a) Why is this problem not just the minimum spanning tree problem? Hint: think negative weight edges.<br>(b) Give an efficient algorithm to compute the minimum weight connected subset T.</p>
<p>解答</p>
<p>若保证子图是连通的，那么T至少包含MST。向MST上添加一条边会怎样？</p>
<ol>
<li>正边：增加T的权值，不要。</li>
<li>0：不改变权值，不要。</li>
<li>负边：减小T的权值，要。</li>
</ol>
<p>因此，所有的负边都不能放过。问题来了，是先生成MST，再把所有的负边添加到MST中构成T，还是先得到所有的负边，再使用Kruskal让图连通得到T呢？</p>
<p>无论哪种方法，<strong>最后T的权值都是一样的</strong>。</p>
<ol>
<li>前面证明了，在MST的边与非MST边e构成的环中，边e之所以不在MST中，就是因为它是环里面最大的，虽然现在边e的权值是负的，但仍然是最大的，因此把e添加进来，不会造成要删除其他MST边。最后得到的T的权值必然是最小的。</li>
<li>先得所有负边，在Kruskal得到的T的权值必然也是最小的，因为它一直都在选最小的边。</li>
</ol>
<h3 id="6-10_feedback-edge_set">6-10 feedback-edge set</h3><p>题目</p>
<p>Let G=(V,E) be an undirected graph. A set F⊆E of edges is called a feedback-edge set if every cycle of G has at least one edge in F.</p>
<p>(a) Suppose that G is unweighted. Design an efficient algorithm to find a minimum-size feedback-edge set.<br>(b) Suppose that G is a weighted undirected graph with positive edge weights. Design an efficient algorithm to find a minimum-weight feedback-edge set.</p>
<p>解答</p>
<p>(a)</p>
<ol>
<li>记录每条边属于哪些环。</li>
<li>拥有最多环的那条边e加入F。</li>
<li>更新每条边，删除它们e中拥有的边，此时e拥有的边变为了0个。</li>
<li>重复2-3，直到所有边不拥有环。</li>
</ol>
<p>时间复杂度嘛，看样子还是不小的。要找到么一个环，然后标记每条边在几个环内，还要排序，删除，不是一个高效的方案。</p>
<p>(b)</p>
<h2 id="并查集">并查集</h2><h3 id="6-12_设计并查集及算法">6-12 设计并查集及算法</h3><p>题目</p>
<p>Devise an efficient data structure to handle the following operations on a weighted directed graph:</p>
<p>(a) Merge two given components.<br>(b) Locate which component contains a given vertex v.<br>(c) Retrieve a minimum edge from a given component.</p>
<p>解答</p>
<p>在课本的并查集操作，得到的并查集是这样的。<br><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-12 b.png" alt="原始并查集结果"></p>
<p>要想确定两个顶点在不在一个集合内，需要找到代表这个集合的根节点，find的效率并不高，他需要多次递归才能得到根节点。</p>
<p>如果能提高find的效率，并查集的操作也将提高很多。常见的做法是，<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="external">路径压缩</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(set_union *s, <span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;p[x] != x)</span><br><span class="line">        s-&gt;p[x] = find(s, s-&gt;p[x]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s-&gt;p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径">最短路径</h2><h3 id="6-14_单目的最短路径">6-14 单目的最短路径</h3><p>题目</p>
<p>The <em>single-destination shortest path</em> problem for a <strong>directed graph</strong> seeks the shortest path from every vertex to a specified vertex v. Give an efficient algorithm to solve the single-destination shortest paths problem.</p>
<p>解答</p>
<p>如果是无向图的话，执行Dijkstra算法即可，然后倒转所有的路径。但是，题目指明是基于有向图的问题。</p>
<p>另外，Kruskal算法是All-Pairs最短路径，如果想到的算法时间复杂度大于O(n<sup>3</sup>)，那还不如直接使用Kruskal。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-14.png" alt="6-14图"></p>
<p>如上图,假设要求从s到t的最短路径，并且已经求得c1,c2,c3到t的最短路径，那么s到t的最短路径应当为 <code>W[s,t] = min(W[s,c1]+W[c1,t], W[s,c2]+W[c2,t], W[s,c3]+W[c3,t])</code>。</p>
<p>自然而然，应当想到了递归解法。Oh，接下来貌似你要考虑一下这些问题：</p>
<ol>
<li>从哪个点开始递归，可以向dfs中那样使用for循环</li>
<li>怎么处理环</li>
<li>。。。</li>
</ol>
<p>再回首想想：<strong>图的解决方案，是对图进行建模，使用已有的算法，而不是设计新的算法</strong></p>
<p>使用Dijkstra算法。反向建立图G’ = (V’,E’), V = V’, {u,v}∈E, {v,u}属于E’。对G’使用Dijkstra算法得到从v到任意节点的最短路径，倒转所有路径即从所有节点到v的最短路径。</p>
<h3 id="6-16_MST与SPT">6-16 MST与SPT</h3><p>题目</p>
<p>Answer all of the following:</p>
<p>(a) Give an example of a weighted connected graph G=(V,E) and a vertex v, such that the minimum spanning tree of G is the same as the shortest-path spanning tree rooted at v.<br>(b) Give an example of a weighted connected directed graph G=(V,E) and a vertex v, such that the <em>minimum-cost spanning tree</em> of G is very different from the shortest-path spanning tree rooted at v.<br>(c) Can the two trees be completely disjointed?</p>
<p>解答</p>
<p>(a) 图G、MST、SP构成的树都是下图：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-16 a.png" alt="Ex 6-16 a"></p>
<p>(b) minimum-cost spanning tree就是MST，看到这个刚开始还觉得这是不是一个新东西。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-16 b.png" alt="Ex 6-16 b"></p>
<p>(c) What is ‘completely disjointed’?</p>
<h3 id="6-17_MST的边与SP的边">6-17 MST的边与SP的边</h3><p>题目</p>
<p>Either prove the following or give a counterexample:</p>
<p>(a) Is the path between a pair of vertices in a minimum spanning tree of an undirected graph necessarily the shortest (minimum weight) path?<br>(b) Suppose that the minimum spanning tree of the graph is unique. Is the path between a pair of vertices in a minimum spanning tree of an undirected graph necessarily the shortest (minimum weight) path?</p>
<p>解答</p>
<p>(a) 否。见上题(b)。边(A,C)就不在最短路径中。</p>
<p>(b) 否。见上题(b)。图G的MST是唯一的，那么现在又回到了题(a)。</p>
<h3 id="6-18_顶点有权值">6-18 顶点有权值</h3><p>题目</p>
<p>In certain graph problems, vertices have can have weights instead of or in addition to the weights of edges. Let Cv be the cost of vertex v, and C(x,y) the cost of the edge (x,y). This problem is concerned with finding the cheapest path between vertices a and b in a graph G. The cost of a path is the sum of the costs of the edges and vertices encountered on the path.</p>
<p>(a) Suppose that each edge in the graph has a weight of zero (while non-edges have a cost of ∞). Assume that Cv=1 for all vertices 1≤v≤n (i.e., all vertices have the same cost). Give an efficient algorithm to find the cheapest path from a to b and its time complexity.<br>(b) Now suppose that the vertex costs are not constant (but are all positive) and the edge costs remain as above. Give an efficient algorithm to find the cheapest path from a to b and its time complexity.<br>(c) Now suppose that both the edge and vertex costs are not constant (but are all positive). Give an efficient algorithm to find the cheapest path from a to b and its time complexity.</p>
<p>解答</p>
<blockquote>
<p>6.3.1 Stop and Think<br>Set the weight of each directed edge{i,j} in the input graph to the cost of vertex j. Dijkstra’s algorithm now does the job.</p>
</blockquote>
<p>我的解决方案：</p>
<p>设边{i,j}的权值为W[i,j]。则将其改为W[i,j] = W[i,j] + C<sub>j</sub>，然后使用Dijkstra。</p>
<p>W[i,j]初始化：<br>(a) W[i,j] = 0.<br>(b) W[i,j] = k(常数).<br>(c) W[i,j] 原本值。</p>
<h3 id="6-19_最小有向环">6-19 最小有向环</h3><p>题目</p>
<p>Let G be a weighted directed graph with n vertices and m edges, where all edges have positive weight. A directed cycle is a directed path that starts and ends at the same vertex and contains at least one edge. Give an O(n<sup>3</sup>) algorithm to find a directed cycle in G of minimum total weight. Partial credit will be given for an O(n<sup>2</sup>m) algorithm.</p>
<p>解答</p>
<p>如果对Floyd的过程比较了解，这个真的很简单，因为Floyd得到的是All-pairs，包括了i到i的最短距离，即<code>g-&gt;weight[i][i]</code>。遍历便可的最小值。</p>
<p>我在做Floyd的时候，对有向图做了测试，<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/floyd.c" target="_blank" rel="external">github传送门</a>。</p>
<h3 id="6-20_最长路径">6-20 最长路径</h3><p>题目</p>
<p>Can we modify Dijkstra’s algorithm to solve the single-source longest path problem by changing {\em minimum} to maximum? If so, then prove your algorithm correct. If not, then provide a counterexample.</p>
<p>解答</p>
<p>Longest path is basically the <em>Hamiltonian Cycle problem</em> or the <em>Traveling Salesman Problem</em>, and it is NP-hard. So no, and if you find a way, then P=NP.</p>
<p>The existence or non-existence of an algorithm to find the largest path, in polynomial time, is essentially part of the largest open problem in all of CS (and probably in math).</p>
<p><a href="http://cs.stackexchange.com/questions/17980/is-it-possible-to-modify-dijkstra-algorithm-in-order-to-get-the-longest-path" target="_blank" rel="external">参考资料1</a><br><a href="http://cs.stackexchange.com/questions/10732/how-to-prove-np-hardness-of-a-longest-path-problem" target="_blank" rel="external">参考资料2</a></p>
<h3 id="6-21_SSSP_线性时间">6-21 SSSP 线性时间</h3><p>题目</p>
<p>Let G=(V,E) be a weighted acyclic directed graph with possibly negative edge weights. Design a linear-time algorithm to solve the single-source shortest-path problem from a given source v.</p>
<p>解答</p>
<ol>
<li><p>使用拓扑排序：O(E+V)<br><a href="http://en.wikipedia.org/wiki/Topological_sorting#Application_to_shortest_path_finding" target="_blank" rel="external">参考资料</a></p>
</li>
<li><p>Google: linear-time algorithm to solve the single-source shortest-path, 会搜到几篇论文，解决方案是修改Dijkstra算法。</p>
</li>
</ol>
<h3 id="6-22_长度为k的最短路径">6-22 长度为k的最短路径</h3><p>题目</p>
<p>Let G=(V,E) be a directed weighted graph such that all the weights are positive. Let v and w be two vertices in G and k≤|V| be an integer. Design an algorithm to find the shortest path from v to w that contains exactly k edges. Note that the path need not be simple.</p>
<p>解答</p>
<p>注意最后一句：意味着图可能存在环的，并且路径中也可以存在环。</p>
<p>比如图为：A&lt;-&gt;B，v=A, w=B.<br>k=1时，A-&gt;B;<br>k=2时，不存在。<br>k=3时，A-&gt;B-&gt;A-&gt;B。</p>

      
    </div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-feature-engineering" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/17/feature-engineering/" class="article-date">
  	<time datetime="2016-03-17T00:49:06.000Z" itemprop="datePublished">2016-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/17/feature-engineering/">特征工程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>特征决定了机器学习的上限，而算法只不过是在逼近这个上限而已。</p>
</blockquote>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据挖掘/">数据挖掘</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/特征/">特征</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/03/17/feature-engineering/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-review-SQL" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/13/review-SQL/" class="article-date">
  	<time datetime="2016-03-13T06:47:20.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/review-SQL/">SQL回顾总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本博文中的所有内容，可以在MySQL 5.6.21中运行。</p>
</blockquote>
<p>MySQL 5.1在线参考手册：<a href="http://doc.mysql.cn/mysql5/refman-5.1-zh.html-chapter/">时光机</a></p>
<h1 id="查询">查询</h1><h2 id="限制行号和偏倚量。">限制行号和偏倚量。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>,<span class="number">3</span>;</span></span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/">SQL</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/03/13/review-SQL/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-project-and-custom-package" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/09/project-and-custom-package/" class="article-date">
  	<time datetime="2016-01-09T02:31:52.000Z" itemprop="datePublished">2016-01-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/09/project-and-custom-package/">对自定义包的引用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>需求驱动学习。</p>
</blockquote>
<h1 id="前言">前言</h1><p>这篇文章是包和单元测试的姊妹篇，内容是如何在自己的工程中导入自定义包，而不出现导入错误。</p>
<p>在文章：<a href="/2016/01/08/package-unittest-import-error/">包和单元测试</a>中，已经叙述了如何单元测试的导入问题，本质上讲，只要导入的模块在搜索路径中，python就可以发现该模块。也验证了<code>python</code>命令会将运行文件所在目录加到<code>sys.path</code>中，而<code>python -m unittest</code>命令，将运行命令所在目录加入到<code>sys.path</code>中。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Package/">Package</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单元测试/">单元测试</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/01/09/project-and-custom-package/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-package-unittest-import-error" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/08/package-unittest-import-error/" class="article-date">
  	<time datetime="2016-01-08T13:51:23.000Z" itemprop="datePublished">2016-01-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/08/package-unittest-import-error/">Python自定义包下不同目录单元测试的导入错误</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>需求驱动学习。</p>
</blockquote>
<h1 id="前言">前言</h1><p>嗯，很绕口的标题</p>
<p>最近的项目需要把编写的工具放到tools目录，把单元测试放到test目录，造成了不同目录下导入（import）的错误。<strong>基础原因很简单，Python无法找到要导入的文件，而解决这个问题的根本方法，是向<code>sys.path</code>中添加搜索路径，如果手动添加，太俗了不是么。</strong></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Package/">Package</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单元测试/">单元测试</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/01/08/package-unittest-import-error/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-never-stop-learning" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/07/never-stop-learning/" class="article-date">
  	<time datetime="2016-01-07T12:40:34.000Z" itemprop="datePublished">2016-01-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/07/never-stop-learning/">不要限制学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>学无止境，莫限制。</p>
</blockquote>
<p>在当初学习Python的时候，对于模块，包并没有细看，当然，书籍上写的也不多，它教会了我：</p>
<ul>
<li>如何使用别人的包、模块。</li>
<li>如何写一个模块，然后在相同的目录下，使用这个模块中的类与函数。</li>
<li>如果不在同目录下，需要将模块在的目录添加到<code>sys.path</code>中。</li>
</ul>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考/">思考</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/01/07/never-stop-learning/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-things-about-github" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/27/things-about-github/" class="article-date">
  	<time datetime="2015-12-27T06:40:01.000Z" itemprop="datePublished">2015-12-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/27/things-about-github/">Github二三事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>总会有些疑问，也总有原因，也必然有解决方案。</p>
</blockquote>
<h2 id="提交者显示unknown">提交者显示unknown</h2><p>明明都是我提交的，怎么显示unkonw commit呢？</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/github-unkonw-commit.png" alt="unknown commit"></p>
<p>原因：本地Git配置的邮箱与Github上面配置的邮箱不一致，具体原因是大小写导致的，本地中有大写字母，而Github上面全为小写。</p>
<h2 id="无法commit或add已经modified的文件(夹)">无法commit或add已经modified的文件(夹)</h2><p>明明显示修改了，但就是提交不上去，原因是那个目录是子模块，有自己的git信息。</p>
<p>参考资料：<a href="http://stackoverflow.com/questions/5186371/problem-with-modified-files-showing-up-in-git-but-not-updating" target="_blank" rel="external">时光机1号</a>，<a href="http://stackoverflow.com/questions/7726131/git-add-a-is-not-adding-all-modified-files-in-directories" target="_blank" rel="external">时光机2号</a>。</p>
<h2 id="http代理带来的问题">http代理带来的问题</h2><p>在push操作的时候出现了这个问题：<code>error: RPC failed; result=56, HTTP code = 0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push ...&#10;error: RPC failed; result=56, HTTP code = 200&#10;fatal: The remote end hung up unexpectedly&#10;fatal: The remote end hung up unexpectedly&#10;Everything up-to-date</span><br></pre></td></tr></table></figure>
<p>原因：git设置的http的缓冲区太小了。</p>
<p>调大即可解决：<code>git config http.postBuffer 524288000</code>。</p>
<p><a href="https://flyingtomoon.com/2013/10/02/using-bitbucket-as-assignment-submission-system-for-the-courses/" target="_blank" rel="external">参考资料</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Github/">Github</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-python-unittest-in-action" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/22/python-unittest-in-action/" class="article-date">
  	<time datetime="2015-12-22T03:09:25.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/22/python-unittest-in-action/">Python单元测试实践</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文主要记录使用Python单元测试时，遇到的问题及解决办法。随着使用的增多，将会遇到更多的问题，与更多的单元测试方法。</p>
</blockquote>
<p>常用的有：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertTrue, assertFalse</span><br><span class="line">assertEqual</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单元测试/">单元测试</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/22/python-unittest-in-action/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-think-about-personal-management" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/21/think-about-personal-management/" class="article-date">
  	<time datetime="2015-12-21T01:09:00.000Z" itemprop="datePublished">2015-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/21/think-about-personal-management/">个人管理的思考</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>从时间管理与记录，周计划，日计划，对理想、目标的渴望，每天告诉自己，我设定的目标。一路走来，至今，我突然开始问自己，今天的计划有助于达成我的目标吗？</p>
</blockquote>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/思考/">思考</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/21/think-about-personal-management/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hexo-errors" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/13/hexo-errors/" class="article-date">
  	<time datetime="2015-12-13T04:21:33.000Z" itemprop="datePublished">2015-12-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/13/hexo-errors/">Hexo博客错误汇总</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="博文格式错误">博文格式错误</h1><h2 id="错误1">错误1</h2><p>错误提示如下：</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/13/hexo-errors/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-back-up-your-blog" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/12/back-up-your-blog/" class="article-date">
  	<time datetime="2015-12-12T08:31:01.000Z" itemprop="datePublished">2015-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/12/back-up-your-blog/">搭好博客勤备份</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前，在搭好博客后我就可是对博客的备份了，备份了配置文件和文章的Markdown文件，以及自己修改的主题。</p>
<p>由于备份的并不是十分勤奋，以至于在我重新做系统后，将备份到Github上的数据Clone到本地后，傻眼了。出现了以下两个大问题：</p>
<ol>
<li>少了几篇文章（一篇文章、笔记可是辛苦了好几天才写出来的呀）。</li>
<li>一些设置没有了，包括博客的自定义主题。</li>
</ol>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blog/">blog</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/12/back-up-your-blog/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Well-Prepared-For-Campus-Recruit" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/01/Well-Prepared-For-Campus-Recruit/" class="article-date">
  	<time datetime="2015-12-01T10:32:13.000Z" itemprop="datePublished">2015-12-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/01/Well-Prepared-For-Campus-Recruit/">校园招聘哪些事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>打算分为以下几个方面记录一些校园资料。虽然大部分都被我存到笔记软件中，以后就放这里吧。笔记软件里面的东西越来越多，尽管已经为每篇笔记设置了标签和分类，但依然有点冗肿了，并且搜索有点慢。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/招聘/">招聘</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2015/12/01/Well-Prepared-For-Campus-Recruit/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 随风
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>