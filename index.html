<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>随风</title>
  <meta name="author" content="James Shi">
  
  <meta name="description" content="屌丝程序员的自留地#为搜索引擎留的">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="随风"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="随风" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">随风</a></h1>
  <h2><a href="/">随风而起，随风而散</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/archives">文章列表</a></li>
    
      <li><a href="/about">我~</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-13T04:21:33.000Z"><a href="/2015/12/13/hexo-errors/">2015-12-13</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/13/hexo-errors/">Hexo博客错误汇总</a></h1>
  

    </header>
    <div class="entry">
      
        
          <div id="toc" class="toc-article">
          <strong class="toc-title">文章目录</strong>
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#博文格式错误"><span class="toc-number">1.</span> <span class="toc-text">博文格式错误</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#错误1"><span class="toc-number">1.1.</span> <span class="toc-text">错误1</span></a></li></ol></li></ol>
          </div>
        
        <h1 id="博文格式错误">博文格式错误</h1><h2 id="错误1">错误1</h2><p>错误提示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g&#10;ERROR Process failed: _posts/how-mistake-python-introduction.md&#10;YAMLException: can not read a block mapping entry; a multiline key may not be an implicit                                                                                           key at line 4, column 1:&#10;&#10;    ^&#10;    at generateError (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\js-yaml\lib\js-                                                                                          yaml\loader.js:160:10)&#10;    at throwError (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\js-yaml\lib\js-yam                                                                                          l\loader.js:166:9)&#10;    at readBlockMapping (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\js-yaml\lib\                                                                                          js-yaml\loader.js:1029:9)&#10;    at composeNode (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\js-yaml\lib\js-ya                                                                                          ml\loader.js:1317:12)&#10;    at readDocument (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\js-yaml\lib\js-y                                                                                          aml\loader.js:1480:3)&#10;    at loadDocuments (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\js-yaml\lib\js-                                                                                          yaml\loader.js:1536:5)&#10;    at Object.load (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\js-yaml\lib\js-ya                                                                                          ml\loader.js:1553:19)&#10;    at parseYAML (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\hexo-front-matter\l                                                                                          ib\front_matter.js:80:21)&#10;    at parse (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\hexo-front-matter\lib\f                                                                                          ront_matter.js:56:12)&#10;    at C:\Users\Brave\MyBlog\node_modules\hexo\lib\plugins\processor\post.js:87:16&#10;    at tryCatcher (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\bluebird\js\main\u                                                                                          til.js:26:23)&#10;    at Promise._settlePromiseFromHandler (C:\Users\Brave\MyBlog\node_modules\hexo\node_mod                                                                                          ules\bluebird\js\main\promise.js:505:31)&#10;    at Promise._settlePromiseAt (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\blue                                                                                          bird\js\main\promise.js:581:18)&#10;    at Promise._settlePromises (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\blueb                                                                                          ird\js\main\promise.js:697:14)&#10;    at Async._drainQueue (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\bluebird\js                                                                                          \main\async.js:123:16)&#10;    at Async._drainQueues (C:\Users\Brave\MyBlog\node_modules\hexo\node_modules\bluebird\j                                                                                          s\main\async.js:133:10)&#10;    at Immediate.Async.drainQueues [as _onImmediate] (C:\Users\Brave\MyBlog\node_modules\h                                                                                          exo\node_modules\bluebird\js\main\async.js:15:14)&#10;    at processImmediate [as _immediateCallback] (timers.js:383:17)&#10;INFO  Files loaded in 3.69 s&#10;INFO  0 files generated in 294 ms</span><br></pre></td></tr></table></figure></p>
<p>重要提示：<br><code>can not read a block mapping entry</code>。</p>
<p>原因：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo&#21338;&#23458;&#38169;&#35823;&#27719;&#24635;&#10;date: 2015-12-13 12:21:33&#10;tags:[&#34;Hexo&#34;] #tags&#20882;&#21495;&#21518;&#38754;&#24212;&#24403;&#26377;&#20010;&#31354;&#26684;,&#20854;&#20182;&#22320;&#26041;&#20063;&#24212;&#24403;&#27880;&#24847;</span><br></pre></td></tr></table></figure></p>
<p>正确格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo&#21338;&#23458;&#38169;&#35823;&#27719;&#24635;&#10;date: 2015-12-13 12:21:33&#10;tags: [&#34;Hexo&#34;]</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-13T04:13:33.000Z"><a href="/2015/12/13/how-mistake-python-introduction/">2015-12-13</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/13/how-mistake-python-introduction/">翻译《Python试错》：前言</a></h1>
  

    </header>
    <div class="entry">
      
        
        <h1 id="序言">序言</h1><p>人孰无过，但真正把事情搞糟糕，你还需要一台计算机。<br>——比尔·沃恩</p>
<p>2000年是互联网泡沫的尾声，自那时起，我开始了Python编程。那段时间我做了许多事情，但那些事情并不能让我引以为豪。其中一些事情非常简单，一些意义深厚，但都伴随的美好的意愿。正如人们所言，我也了犯许多错误。这让我付出了昂贵的代价，大多数让我很囧。通过讨论、探究、一层一层的分析这些错误，我希望这能对你有所帮助。</p>
<p>我思考了作为Python程序员我所犯的这些错误，他们或多或少可以分为以下几类：</p>
<ol>
<li><strong>安装</strong>：阻碍来自未充分准备的安装环境。</li>
<li><strong>愚蠢的事情</strong>：琐碎的错误浪费了我大量的体力。</li>
<li><strong>风格</strong>：不好的编程风格阻碍了程序的可读性。</li>
<li><strong>结构</strong>：组织代码的形式使得改变代码很困难。</li>
<li><strong>惊喜</strong>：令人震惊的神秘方法，使我破涕为笑。</li>
</ol>
<p>在我们开始之前，还有几个快速的事情需要我们解决。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-12T08:31:01.000Z"><a href="/2015/12/12/back-up-your-blog/">2015-12-12</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/12/back-up-your-blog/">搭好博客勤备份</a></h1>
  

    </header>
    <div class="entry">
      
        
          <div id="toc" class="toc-article">
          <strong class="toc-title">文章目录</strong>
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#那么，什么需要备份呢？"><span class="toc-number">1.</span> <span class="toc-text">那么，什么需要备份呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#备份到哪里？"><span class="toc-number">2.</span> <span class="toc-text">备份到哪里？</span></a></li></ol>
          </div>
        
        <p>之前，在搭好博客后我就可是对博客的备份了，备份了配置文件和文章的Markdown文件，以及自己修改的主题。</p>
<p>由于备份的并不是十分勤奋，以至于在我重新做系统后，将备份到Github上的数据Clone到本地后，傻眼了。出现了以下两个大问题：</p>
<ol>
<li>少了几篇文章（一篇文章、笔记可是辛苦了好几天才写出来的呀）。</li>
<li>一些设置没有了，包括博客的自定义主题。</li>
</ol>
<h3 id="那么，什么需要备份呢？">那么，什么需要备份呢？</h3><p>以下举例以Hexo的文件为例。</p>
<ol>
<li>博客配置文件，如<code>_config.yml</code>。</li>
<li>主题文件夹，如themes目录下自己自定义的主题。</li>
<li>发表过的博文，如source目录。</li>
</ol>
<p>如果想省事，可以对整个Hexo博客文件进行完整备份，但是备份前需要进行<code>hexo clean</code>，清理掉一些临时的缓存文件（如public目录）。</p>
<h3 id="备份到哪里？">备份到哪里？</h3><p>如今流行备份到云端，如果没有什么机密的东西，就备份到云上，并且随处可取。如果备份到本地私有服务器，就没有放在网络上方便了。于云端而言，可以备份到网盘、Github等托管网站。</p>
<p>对比备份到网盘与Github的等托管网站的特点。</p>
<p>网盘特点：<br>国内网盘备份速度快；可自动备份，省心；相对较私密，只要自己不设置共享。</p>
<p>Github特点：<br>备份速度慢点；需手动Push（当然你可以写个脚本自动Push，然后再设个计划任务，每天自动备份）；共享。</p>
<p>如今我乐意备份到这两个地方，多一份保险。网盘采取自动备份，这样基本确保了<strong>及时备份</strong>，Git采取手动定期备份。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-12T08:24:02.540Z"><a href="/2015/12/12/Ch6-Exercises-and-Solutions-of-TADM2E/">2015-12-12</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/12/Ch6-Exercises-and-Solutions-of-TADM2E/"></a></h1>
  

    </header>
    <div class="entry">
      
        
          <div id="toc" class="toc-article">
          <strong class="toc-title">文章目录</strong>
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">算法设计手册第二版第六章课后习题解答</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目Wiki及参考答案"><span class="toc-number">1.1.</span> <span class="toc-text">题目Wiki及参考答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MST"><span class="toc-number">1.2.</span> <span class="toc-text">MST</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2_最短路径与MST"><span class="toc-number">1.2.1.</span> <span class="toc-text">6-2 最短路径与MST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3_最短路径与MST"><span class="toc-number">1.2.2.</span> <span class="toc-text">6-3 最短路径与MST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4_Prim和Kruskal得到MST是否相同"><span class="toc-number">1.2.3.</span> <span class="toc-text">6-4 Prim和Kruskal得到MST是否相同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5_Prim和Kruskal边权值是否可为负"><span class="toc-number">1.2.4.</span> <span class="toc-text">6-5 Prim和Kruskal边权值是否可为负</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6_添加边，获得新的MST"><span class="toc-number">1.2.5.</span> <span class="toc-text">6-6 添加边，获得新的MST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7_改变权值，MST是否改变，最短路径是否改变"><span class="toc-number">1.2.6.</span> <span class="toc-text">6-7 改变权值，MST是否改变，最短路径是否改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8_已最小的代价改变MST"><span class="toc-number">1.2.7.</span> <span class="toc-text">6-8 已最小的代价改变MST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9_最小连通子集"><span class="toc-number">1.2.8.</span> <span class="toc-text">6-9 最小连通子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10_feedback-edge_set"><span class="toc-number">1.2.9.</span> <span class="toc-text">6-10 feedback-edge set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并查集"><span class="toc-number">1.3.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-12_设计并查集及算法"><span class="toc-number">1.3.1.</span> <span class="toc-text">6-12 设计并查集及算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最短路径"><span class="toc-number">1.4.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-14_单目的最短路径"><span class="toc-number">1.4.1.</span> <span class="toc-text">6-14 单目的最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-16_MST与SPT"><span class="toc-number">1.4.2.</span> <span class="toc-text">6-16 MST与SPT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-17_MST的边与SP的边"><span class="toc-number">1.4.3.</span> <span class="toc-text">6-17 MST的边与SP的边</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-18_顶点有权值"><span class="toc-number">1.4.4.</span> <span class="toc-text">6-18 顶点有权值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-19_最小有向环"><span class="toc-number">1.4.5.</span> <span class="toc-text">6-19 最小有向环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-20_最长路径"><span class="toc-number">1.4.6.</span> <span class="toc-text">6-20 最长路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-21_SSSP_线性时间"><span class="toc-number">1.4.7.</span> <span class="toc-text">6-21 SSSP 线性时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-22_长度为k的最短路径"><span class="toc-number">1.4.8.</span> <span class="toc-text">6-22 长度为k的最短路径</span></a></li></ol></li></ol></li></ol>
          </div>
        
        
<h1 class="title">算法设计手册第二版第六章课后习题解答</h1>



<div class="entry">

<blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Weighted-graphs-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Weighted-graphs-TADM2E</a></p>
<p>该页面答案，也是由用户编辑的，不确定是完全的正确。</p>
<h2 id="MST">MST</h2><h3 id="6-2_最短路径与MST">6-2 最短路径与MST</h3><p>题目</p>
<p>Is the path between two vertices in a minimum spanning tree necessarily a shortest path between the two vertices in the full graph? Give a proof or a counterexample.</p>
<p>解答</p>
<p>MST中两点间的路径不是该两点在整个图中的最短路径。</p>
<p><strong>反例：</strong>使用习题5-1的图，使用Kruskal得到的MST是：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-2-1.JPG" alt="习题5-1图"></p>
<a id="more"></a>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-2.JPG" alt="习题5-1图的MST"></p>
<p>路径A-&gt;I：A-&gt;D-&gt;G-&gt;J-&gt;I。路径长度为13，而在整个图中，路劲为A-&gt;I，长度为9。结果已显然。</p>
<h3 id="6-3_最短路径与MST">6-3 最短路径与MST</h3><p>题目</p>
<p>Assume that all edges in the graph have distinct edge weights (i.e., no pair of edges have the same weight). Is the path between a pair of vertices in a minimum spanning tree necessarily a shortest path between the two vertices in the full graph? Give a proof or a counterexample.</p>
<p>解答</p>
<p>否。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-3.JPG" alt="反例图及其MST"></p>
<p>考虑B到D的路径，在图中路径长度为6，而在MST中路径长度为7。</p>
<h3 id="6-4_Prim和Kruskal得到MST是否相同">6-4 Prim和Kruskal得到MST是否相同</h3><p>题目</p>
<p>Can Prim’s and Kruskal’s algorithm yield different minimum spanning trees? Explain why or why not.</p>
<p>解答</p>
<p>在6-1中，Prim与Kruskal就可以产生不同MST。只有当MST本身唯一的时候，由Prim与Kruskal得到的MST才是相同的。</p>
<p>MST唯一的条件：所有边的权值都不相同。</p>
<h3 id="6-5_Prim和Kruskal边权值是否可为负">6-5 Prim和Kruskal边权值是否可为负</h3><p>题目</p>
<p>Does either Prim’s and Kruskal’s algorithm work if there are negative edge weights? Explain why or why not.</p>
<p>解答</p>
<p>思考得到的想法和Wiki页面的想法是类似的，但我还不会严谨的证明。</p>
<p>每条边都会被访问一次，并且只是比较边的大小，既然是仅仅比较大小，那么与正负是没有关系的。不会像Dijkstra那样对边的权值有加法操作，会影响整体的结果。</p>
<h3 id="6-6_添加边，获得新的MST">6-6 添加边，获得新的MST</h3><p>题目</p>
<p>Suppose we are given the minimum spanning tree T of a given graph G (with n vertices and m edges) and a new edge e=(u,v) of weight w that we will add to G. Give an efficient algorithm to find the minimum spanning tree of the graph G+e. Your algorithm should run in O(n) time to receive full credit.</p>
<p>解答</p>
<p>向MST中添加一条边会怎样？对，出现环路。如果增加的边的权值w比从u到v的路径上最大边的权值要小，那么就需要删除掉该最大的边。</p>
<p>从u开始对MST进行DFS可以得到最大的边，时间O(n)。</p>
<p>Google了这道题目，得到了一份考卷，对该问题进行了扩展。题目及答案如下：</p>
<p>Suppose you are given a graph G=(V,E) with edge weights w(e) and a minimum spanning tree T of G. Now, suppose a new edge {u,v} is added to G. Describe (in words) a method for determining if T is still a minimum spanning tree for G.</p>
<p><em>Examine the path in T from u to v. If any vertex on this path has weight larger than that of the new edge, then T is no longer an MST. We can modify T to obtain a new MST by removing the max weight edge on this path and replacing it with the new edge.</em></p>
<p>Explain how your method can be implemented to run in O(n) time if both G and T are provided as instances of the wgraph data structure.</p>
<p><em>Using the wgraph for T, we can do a recursive tree traversal in T, starting at vertex u. Once the traversal reaches v, we “unwind” the recursion, and as we do so, we look for the max weight edge along the u,v path. The runtime for a tree traversal is O(n) and the required changes to T can be done in constant time.</em></p>
<p>Suppose that instead of a single edge, you are given a set of k new edges to add to G. For small enough k it makes sense to apply your algorithm repeatedly in order to update the MST, but if k is “too large”, it’s more efficient to re-compute the MST from scratch. How big does k have to be (as a function of m and n) in order for this to be a better choice? Assume that the MST is computed using Prim’s algorithm with a d-heap, where d=2.</p>
<p><em>When d=2, the running time for Prim’s algorithm is O(m log n), so if kn grows faster than this, it makes sense to recompute from scratch. So, if k&gt;(m/n) log n, it makes sense to recompute the MST.</em></p>
<h3 id="6-7_改变权值，MST是否改变，最短路径是否改变">6-7 改变权值，MST是否改变，最短路径是否改变</h3><p>题目</p>
<p>(a) Let T be a minimum spanning tree of a weighted graph G. Construct a new graph G′ by adding a weight of k to every edge of G. Do the edges of T form a minimum spanning tree of G′? Prove the statement or give a counterexample. </p>
<p>(b) Let P={s,…,t} describe a shortest weighted path between vertices s and t of a weighted graph G. Construct a new graph G′ by adding a weight of k to every edge of G. Does P describe a shortest path from s to t in G′? Prove the statement or give a counterexample.</p>
<p>解答</p>
<p>(a) 是的。</p>
<p>6-5中提到了，MST与权值的具体数值无关，只要能比较边的大小即可。每条边的权值都增加了k，它们依然是可以比较大小的，并且它们的相对大小并没有变化，因此T会是G’的一个MST。</p>
<p><em>这点我同答案wiki页面是不同的，那里面的回答是“可能是”。</em></p>
<p>(b) 答案不确定。</p>
<p>Dijkstra算法：只能处理非负权值的边。<br>Floyd-Warshall算法：能处理包含负边的图，但不能处理存在负边构成环的图。</p>
<ol>
<li>只要不存在负权值的边，答案是肯定的，依然是P。</li>
<li>存在负边时，我不确定。</li>
</ol>
<h3 id="6-8_已最小的代价改变MST">6-8 已最小的代价改变MST</h3><p>题目</p>
<p>Devise and analyze an algorithm that takes a weighted graph G and finds the smallest change in the cost to a non-MST edge that would cause a change in the minimum spanning tree of G. Your algorithm must be correct and run in polynomial time.</p>
<p>解答</p>
<p>polynomial time：2<sup>O(log n)</sup>, eg. n, nlogn, n<sup>10</sup>。</p>
<p>什么样的边会影响最小生成树？</p>
<p>在图的某个环中，除了这条边e，其他边都是MST中的边，那么只要e小于其中任何一条边的值就可以改变MST。</p>
<p>再详细一点，边e是环中最大的边，边x是该环剩下的边在MST中最大的边。只要使得边e的值略小于边x的值即可，这样可以保证最小的代价改变MST。</p>
<p>以6-2中的图为例，边(I,G)、(E,G)是符合条件的，减1即可，其他非MST边减的都大于1才能改变MST。</p>
<p>假设n个点，m条边，则非MST边有(m-n+1)，根据MST找到每条边所在换，并计算最小变化需要O(n)，则时间复杂度为O(n(m-n))。</p>
<p><em>我相信这不是最好的解决方案。</em></p>
<h3 id="6-9_最小连通子集">6-9 最小连通子集</h3><p>题目</p>
<p>Consider the problem of finding a minimum weight connected subset T of edges from a weighted connected graph G. The weight of T is the sum of all the edge weights in T.</p>
<p>(a) Why is this problem not just the minimum spanning tree problem? Hint: think negative weight edges.<br>(b) Give an efficient algorithm to compute the minimum weight connected subset T.</p>
<p>解答</p>
<p>若保证子图是连通的，那么T至少包含MST。向MST上添加一条边会怎样？</p>
<ol>
<li>正边：增加T的权值，不要。</li>
<li>0：不改变权值，不要。</li>
<li>负边：减小T的权值，要。</li>
</ol>
<p>因此，所有的负边都不能放过。问题来了，是先生成MST，再把所有的负边添加到MST中构成T，还是先得到所有的负边，再使用Kruskal让图连通得到T呢？</p>
<p>无论哪种方法，<strong>最后T的权值都是一样的</strong>。</p>
<ol>
<li>前面证明了，在MST的边与非MST边e构成的环中，边e之所以不在MST中，就是因为它是环里面最大的，虽然现在边e的权值是负的，但仍然是最大的，因此把e添加进来，不会造成要删除其他MST边。最后得到的T的权值必然是最小的。</li>
<li>先得所有负边，在Kruskal得到的T的权值必然也是最小的，因为它一直都在选最小的边。</li>
</ol>
<h3 id="6-10_feedback-edge_set">6-10 feedback-edge set</h3><p>题目</p>
<p>Let G=(V,E) be an undirected graph. A set F⊆E of edges is called a feedback-edge set if every cycle of G has at least one edge in F.</p>
<p>(a) Suppose that G is unweighted. Design an efficient algorithm to find a minimum-size feedback-edge set.<br>(b) Suppose that G is a weighted undirected graph with positive edge weights. Design an efficient algorithm to find a minimum-weight feedback-edge set.</p>
<p>解答</p>
<p>(a)</p>
<ol>
<li>记录每条边属于哪些环。</li>
<li>拥有最多环的那条边e加入F。</li>
<li>更新每条边，删除它们e中拥有的边，此时e拥有的边变为了0个。</li>
<li>重复2-3，直到所有边不拥有环。</li>
</ol>
<p>时间复杂度嘛，看样子还是不小的。要找到么一个环，然后标记每条边在几个环内，还要排序，删除，不是一个高效的方案。</p>
<p>(b)</p>
<h2 id="并查集">并查集</h2><h3 id="6-12_设计并查集及算法">6-12 设计并查集及算法</h3><p>题目</p>
<p>Devise an efficient data structure to handle the following operations on a weighted directed graph:</p>
<p>(a) Merge two given components.<br>(b) Locate which component contains a given vertex v.<br>(c) Retrieve a minimum edge from a given component.</p>
<p>解答</p>
<p>在课本的并查集操作，得到的并查集是这样的。<br><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-12 b.png" alt="原始并查集结果"></p>
<p>要想确定两个顶点在不在一个集合内，需要找到代表这个集合的根节点，find的效率并不高，他需要多次递归才能得到根节点。</p>
<p>如果能提高find的效率，并查集的操作也将提高很多。常见的做法是，<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="external">路径压缩</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(set_union *s, <span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;p[x] != x)</span><br><span class="line">        s-&gt;p[x] = find(s, s-&gt;p[x]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s-&gt;p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径">最短路径</h2><h3 id="6-14_单目的最短路径">6-14 单目的最短路径</h3><p>题目</p>
<p>The <em>single-destination shortest path</em> problem for a <strong>directed graph</strong> seeks the shortest path from every vertex to a specified vertex v. Give an efficient algorithm to solve the single-destination shortest paths problem.</p>
<p>解答</p>
<p>如果是无向图的话，执行Dijkstra算法即可，然后倒转所有的路径。但是，题目指明是基于有向图的问题。</p>
<p>另外，Kruskal算法是All-Pairs最短路径，如果想到的算法时间复杂度大于O(n<sup>3</sup>)，那还不如直接使用Kruskal。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-14.png" alt="6-14图"></p>
<p>如上图,假设要求从s到t的最短路径，并且已经求得c1,c2,c3到t的最短路径，那么s到t的最短路径应当为 <code>W[s,t] = min(W[s,c1]+W[c1,t], W[s,c2]+W[c2,t], W[s,c3]+W[c3,t])</code>。</p>
<p>自然而然，应当想到了递归解法。Oh，接下来貌似你要考虑一下这些问题：</p>
<ol>
<li>从哪个点开始递归，可以向dfs中那样使用for循环</li>
<li>怎么处理环</li>
<li>。。。</li>
</ol>
<p>再回首想想：<strong>图的解决方案，是对图进行建模，使用已有的算法，而不是设计新的算法</strong></p>
<p>使用Dijkstra算法。反向建立图G’ = (V’,E’), V = V’, {u,v}∈E, {v,u}属于E’。对G’使用Dijkstra算法得到从v到任意节点的最短路径，倒转所有路径即从所有节点到v的最短路径。</p>
<h3 id="6-16_MST与SPT">6-16 MST与SPT</h3><p>题目</p>
<p>Answer all of the following:</p>
<p>(a) Give an example of a weighted connected graph G=(V,E) and a vertex v, such that the minimum spanning tree of G is the same as the shortest-path spanning tree rooted at v.<br>(b) Give an example of a weighted connected directed graph G=(V,E) and a vertex v, such that the <em>minimum-cost spanning tree</em> of G is very different from the shortest-path spanning tree rooted at v.<br>(c) Can the two trees be completely disjointed?</p>
<p>解答</p>
<p>(a) 图G、MST、SP构成的树都是下图：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-16 a.png" alt="Ex 6-16 a"></p>
<p>(b) minimum-cost spanning tree就是MST，看到这个刚开始还觉得这是不是一个新东西。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 6-16 b.png" alt="Ex 6-16 b"></p>
<p>(c) What is ‘completely disjointed’?</p>
<h3 id="6-17_MST的边与SP的边">6-17 MST的边与SP的边</h3><p>题目</p>
<p>Either prove the following or give a counterexample:</p>
<p>(a) Is the path between a pair of vertices in a minimum spanning tree of an undirected graph necessarily the shortest (minimum weight) path?<br>(b) Suppose that the minimum spanning tree of the graph is unique. Is the path between a pair of vertices in a minimum spanning tree of an undirected graph necessarily the shortest (minimum weight) path?</p>
<p>解答</p>
<p>(a) 否。见上题(b)。边(A,C)就不在最短路径中。</p>
<p>(b) 否。见上题(b)。图G的MST是唯一的，那么现在又回到了题(a)。</p>
<h3 id="6-18_顶点有权值">6-18 顶点有权值</h3><p>题目</p>
<p>In certain graph problems, vertices have can have weights instead of or in addition to the weights of edges. Let Cv be the cost of vertex v, and C(x,y) the cost of the edge (x,y). This problem is concerned with finding the cheapest path between vertices a and b in a graph G. The cost of a path is the sum of the costs of the edges and vertices encountered on the path.</p>
<p>(a) Suppose that each edge in the graph has a weight of zero (while non-edges have a cost of ∞). Assume that Cv=1 for all vertices 1≤v≤n (i.e., all vertices have the same cost). Give an efficient algorithm to find the cheapest path from a to b and its time complexity.<br>(b) Now suppose that the vertex costs are not constant (but are all positive) and the edge costs remain as above. Give an efficient algorithm to find the cheapest path from a to b and its time complexity.<br>(c) Now suppose that both the edge and vertex costs are not constant (but are all positive). Give an efficient algorithm to find the cheapest path from a to b and its time complexity.</p>
<p>解答</p>
<blockquote>
<p>6.3.1 Stop and Think<br>Set the weight of each directed edge{i,j} in the input graph to the cost of vertex j. Dijkstra’s algorithm now does the job.</p>
</blockquote>
<p>我的解决方案：</p>
<p>设边{i,j}的权值为W[i,j]。则将其改为W[i,j] = W[i,j] + C<sub>j</sub>，然后使用Dijkstra。</p>
<p>W[i,j]初始化：<br>(a) W[i,j] = 0.<br>(b) W[i,j] = k(常数).<br>(c) W[i,j] 原本值。</p>
<h3 id="6-19_最小有向环">6-19 最小有向环</h3><p>题目</p>
<p>Let G be a weighted directed graph with n vertices and m edges, where all edges have positive weight. A directed cycle is a directed path that starts and ends at the same vertex and contains at least one edge. Give an O(n<sup>3</sup>) algorithm to find a directed cycle in G of minimum total weight. Partial credit will be given for an O(n<sup>2</sup>m) algorithm.</p>
<p>解答</p>
<p>如果对Floyd的过程比较了解，这个真的很简单，因为Floyd得到的是All-pairs，包括了i到i的最短距离，即<code>g-&gt;weight[i][i]</code>。遍历便可的最小值。</p>
<p>我在做Floyd的时候，对有向图做了测试，<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/floyd.c" target="_blank" rel="external">github传送门</a>。</p>
<h3 id="6-20_最长路径">6-20 最长路径</h3><p>题目</p>
<p>Can we modify Dijkstra’s algorithm to solve the single-source longest path problem by changing {\em minimum} to maximum? If so, then prove your algorithm correct. If not, then provide a counterexample.</p>
<p>解答</p>
<p>Longest path is basically the <em>Hamiltonian Cycle problem</em> or the <em>Traveling Salesman Problem</em>, and it is NP-hard. So no, and if you find a way, then P=NP.</p>
<p>The existence or non-existence of an algorithm to find the largest path, in polynomial time, is essentially part of the largest open problem in all of CS (and probably in math).</p>
<p><a href="http://cs.stackexchange.com/questions/17980/is-it-possible-to-modify-dijkstra-algorithm-in-order-to-get-the-longest-path" target="_blank" rel="external">参考资料1</a><br><a href="http://cs.stackexchange.com/questions/10732/how-to-prove-np-hardness-of-a-longest-path-problem" target="_blank" rel="external">参考资料2</a></p>
<h3 id="6-21_SSSP_线性时间">6-21 SSSP 线性时间</h3><p>题目</p>
<p>Let G=(V,E) be a weighted acyclic directed graph with possibly negative edge weights. Design a linear-time algorithm to solve the single-source shortest-path problem from a given source v.</p>
<p>解答</p>
<ol>
<li><p>使用拓扑排序：O(E+V)<br><a href="http://en.wikipedia.org/wiki/Topological_sorting#Application_to_shortest_path_finding" target="_blank" rel="external">参考资料</a></p>
</li>
<li><p>Google: linear-time algorithm to solve the single-source shortest-path, 会搜到几篇论文，解决方案是修改Dijkstra算法。</p>
</li>
</ol>
<h3 id="6-22_长度为k的最短路径">6-22 长度为k的最短路径</h3><p>题目</p>
<p>Let G=(V,E) be a directed weighted graph such that all the weights are positive. Let v and w be two vertices in G and k≤|V| be an integer. Design an algorithm to find the shortest path from v to w that contains exactly k edges. Note that the path need not be simple.</p>
<p>解答</p>
<p>注意最后一句：意味着图可能存在环的，并且路径中也可以存在环。</p>
<p>比如图为：A&lt;-&gt;B，v=A, w=B.<br>k=1时，A-&gt;B;<br>k=2时，不存在。<br>k=3时，A-&gt;B-&gt;A-&gt;B。</p>

      
    </div>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-12T07:43:28.234Z"><a href="/2015/12/12/Ch7-Exercises-and-Solutions-of-TADM2E/">2015-12-12</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/12/Ch7-Exercises-and-Solutions-of-TADM2E/"></a></h1>
  

    </header>
    <div class="entry">
      
        
          <div id="toc" class="toc-article">
          <strong class="toc-title">文章目录</strong>
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">算法设计手册第二版第七章课后习题解答</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目Wiki及参考答案"><span class="toc-number">1.1.</span> <span class="toc-text">题目Wiki及参考答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Backtracking"><span class="toc-number">1.2.</span> <span class="toc-text">Backtracking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1_permutations"><span class="toc-number">1.2.1.</span> <span class="toc-text">7-1 permutations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2_Multisets"><span class="toc-number">1.2.2.</span> <span class="toc-text">7-2 Multisets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3_图的同构"><span class="toc-number">1.2.3.</span> <span class="toc-text">7-3 图的同构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4"><span class="toc-number">1.2.4.</span> <span class="toc-text">7-4</span></a></li></ol></li></ol></li></ol>
          </div>
        
        <h1>算法设计手册第二版第七章课后习题解答</h1>
    <div class="entry">
      

        
        <blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Search-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Search-TADM2E</a></p>
<p>该页面答案，也是由用户编辑的，不确定是完全的正确。</p>
<h2 id="Backtracking">Backtracking</h2><h3 id="7-1_permutations">7-1 permutations</h3><p>题目</p>
<p>A derangement is a permutation p of {1,…,n} such that no item is in its proper position, i.e. pi≠i for all 1≤i≤n. derangement Write an efficient backtracking program with pruning that constructs all the derangements of n items.</p>
<p>解答</p>
<p>剪枝就是构建合适的候选者。只需增加一个限制条件<code>i != k</code>。<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/7.11/7_1_permutations.c" target="_blank" rel="external">完整代码</a>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> construct_candidates(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> c[], <span class="keyword">int</span> *ncandidates)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">bool</span> in_perm[NMAX];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;NMAX; ++i) in_perm[i] = <span class="literal">FALSE</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;k; ++i)  in_perm[a[i]] = <span class="literal">TRUE</span>;</span><br><span class="line">  *ncandidates = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i != k &amp;&amp; in_perm[i] == <span class="literal">FALSE</span>) <span class="comment">// pruning</span></span><br><span class="line">      c[(*ncandidates)++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2_Multisets">7-2 Multisets</h3><p>题目</p>
<p>Multisets are allowed to have repeated elements. A multiset of n items may thus have fewer than n! distinct permutations. For example, {1,1,2,2} has only six different permutations: {1,1,2,2}, {1,2,1,2}, {1,2,2,1}, {2,1,1,2}, {2,1,2,1}, and {2,2,1,1}. multiset Design and implement an efficient algorithm for constructing all permutations of a multiset.</p>
<p>解答</p>
<p>在每次选取候选者的时候，重复的候选者，只选择一个，就不会出现同一个数字在同一个位置，出现多次。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mulset[NMAX];            <span class="comment">// Multisets</span></span><br><span class="line">a[];                     <span class="comment">// save the indexes of the number in mulset</span></span><br><span class="line"><span class="keyword">void</span> construct_candidates(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> c[], <span class="keyword">int</span> *ncandidates)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">bool</span> in_perm[NMAX];   <span class="comment">// save the indexes of the number in mulset</span></span><br><span class="line">  <span class="keyword">int</span> uniset[NMAX];     <span class="comment">// save the first indexes of a number in mulset</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;NMAX; ++i) in_perm[i] = <span class="literal">FALSE</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;k; ++i)  in_perm[a[i]] = <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">  get_unique_set(in_perm, uniset); </span><br><span class="line"></span><br><span class="line">  *ncandidates = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i != k &amp;&amp; uniset[i] == <span class="literal">FALSE</span>) <span class="comment">// pruning</span></span><br><span class="line">      c[(*ncandidates)++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3_图的同构">7-3 图的同构</h3><p>题目</p>
<p>Design and implement an algorithm for testing whether two graphs are isomorphic to each other. The graph isomorphism problem is discussed in graph-isomorphism. With proper pruning, graphs on hundreds of vertices can be tested reliably.</p>
<p>解答</p>
<p>NP问题。</p>
<p>方法就是进行验证。</p>
<p>以无向图举例。</p>
<ol>
<li>顶点数量相同。</li>
<li>在图G中任选一点，依次与图H中的点进行匹配。</li>
<li>那么总的配对方式供NxN个。</li>
<li>验证方式是：图G中有的边，图H中也有，图H中有的边图G中也有。</li>
</ol>
<p>剪枝：仅将H中与G中当前顶点度相同的顶点加入到候选者列表。</p>
<h3 id="7-4">7-4</h3><p>题目</p>
<p>Anagrams are rearrangements of the letters of a word or phrase into a different word or phrase. Sometimes the results are quite striking. For example, “MANY VOTED BUSH RETIRED” is an anagram of “TUESDAY NOVEMBER THIRD”, which correctly predicted the result of the 1992 U.S. presidential election. Design and implement an algorithm for finding anagrams using combinatorial search and a dictionary.</p>
<p>解答</p>
<ol>
<li>根据输入字符串，拆解得到一个字符池。池中字母保持字典顺序。</li>
<li>按照课本构造子集的方式，得到一个子集，即一个“单词”，判断该单词在不在词典中？<br> 2.1 在，则从剩下的字符池继续构建单词，直到池为空，得到一个solution；<br> 2.2 否，构建下一个单词。</li>
</ol>

      
    </div>
    
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-01T10:32:13.000Z"><a href="/2015/12/01/Well-Prepared-For-Campus-Recruit/">2015-12-01</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/01/Well-Prepared-For-Campus-Recruit/">校园招聘哪些事</a></h1>
  

    </header>
    <div class="entry">
      
        
        <p>打算分为以下几个方面记录一些校园资料。虽然大部分都被我存到笔记软件中，以后就放这里吧。笔记软件里面的东西越来越多，尽管已经为每篇笔记设置了标签和分类，但依然有点冗肿了，并且搜索有点慢。</p>
<h1 id="那些人的故事">那些人的故事</h1><p><a href="http://zipperary.com/2015/11/07/campus-2016/" target="_blank" rel="external">http://zipperary.com/2015/11/07/campus-2016/</a></p>
<h1 id="你会写简历吗">你会写简历吗</h1>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-29T16:00:00.000Z"><a href="/2015/11/30/How-to-Select-Programming-Language-md/">2015-11-30</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/30/How-to-Select-Programming-Language-md/">如何选择编程语言</a></h1>
  

    </header>
    <div class="entry">
      
        
        <blockquote>
<p>随着认识的积累，对编程语言的看法也在改变。</p>
</blockquote>
<p>以下内容，纯吐槽。</p>
<h1 id="C，C++，Java">C，C++，Java</h1><p>本科的时候只接触了C，C++，Java，那就先吐槽一下他们吧。</p>
<p>期初很狭隘的认为学习一两个编程语言就足够了，这样就可以做许多东西了，学那么多编程语言有必要吗？</p>
<p>学C++的时候，终于可以简单的使用输入了，然而输出格式反而不太好控制了，更重要的是，感觉C++有更多的库呀，不用重复造轮子了。</p>
<p>然而，现在看来，造轮子也是一件很伟大的事情，如果没有造轮子汗如雨下的付出，你哪有那么多轮子用。</p>
<p>学Java的时候，感觉比C++好使，可是代码怎么就不能一句两句写清楚呢，非得封装封装再封装。整的本来一两句说清楚的事，码了10来行。</p>
<p>回想本科时期，基本都是在用C，这个老师用C，那个老师用C，所以你交作业的时候，也不得不用C啊。Java只是在选Java，J2EE和写Android小程序的时候用过，至今都不太愿意看Java代码，写的感觉长，读起来，感觉也漫长无比，若是码代码的之前不加注释，简直感觉坑die。</p>
<h1 id="C#，Ruby，Python">C#，Ruby，Python</h1><p>研究生阶段又接触了一些语言，比如C#，Ruby，Python，那就再吐槽一下他们。</p>
<p>进入实验室后，需要维护or改造一个软件，现在回想起来，那软件简直就是一个深坑，耗费了大半年青春，唯一的收获就是让我码了半年的C#，现在可以吐槽一下他。</p>
<p>反正学过C++，Java写起C#来也不费劲，期初就了解一下STL中的那些功能在C#里面是什么东东，也顺便学习了Windows的事件响应机制。不过画说回来，在VS中写C#还是很爽的，与写C++相比，简直是66666666666的一B，用起来那叫一个顺手。当初当助教，为了批处理学生的作业，还能整个界面小程序，省了不少事。</p>
<p>在研一春节的时候，在家无聊，那时家中只有电线，没有网线。每年回家，那叫一个苦啊，只能玩玩手机什么的。那年初一，在我堂哥家下载了一个Ruby，安装在自己笔记本上了，然而Ruby安装后，文件夹里有简要的教程，用Ruby写代码果然精简，省事呀，那几天过的也是挺爽的。</p>
<p>为嘛在初一写Ruby，脑进水了吗(⊙o⊙)？</p>
<p>都是Steve Yegge惹的祸，他写了一本书《程序员的呐喊》吐槽了不少编程语言，我看的也正High，并且他还夸赞了一下Ruby，当时我对Ruby的概念就是，这是一个脚本语言，标志是一个红宝石，岛国某程序员开发的。</p>
<p>当时，我还在看另外一本书，Paul Graham（什么！你不知道他是谁！请自行百度or Google）写的《黑客与画家》，保罗本人酷爱函数式编程，在书里面没少夸奖了Lisp，最后的附录里面还是哪里还对比了，Lisp，Ruby，Python，在他眼里虽然Ruby比不上Lisp，但至少Ruby接近Lisp的简洁了，然后再试Python。所以我也就看了一下Ruby，反正寒假在家也没什么事情做。</p>
<p>学起来Ruby还是很有意思的。这也为我后来学习Python省了不少力气，毕竟二者还是很相近的。</p>
<p>寒假悠然远去，终于开学了。</p>
<p>那段时间C#那个坑die的项目还有结束，后面又改了一段时间。边改边看Rails，因为都说没有Rails估计用Ruby的程序员会缩减到所剩无几。看Rails多少让我了解了一下web的框架，对后面学习Django多少也是有帮助的。</p>
<p>暑假之前终于回归到数据挖掘的正途上，毕竟这才是实验室的研究方向嘛。</p>
<p>在数据挖掘方面，如今Python非常流行，虽然实验室的师兄有的用Java，有的用Matlab，但是和我同级的小伙伴相对来喜欢Python，原因超级的简单，工具包丰富，写的代码还短，用起来方便，也许这就是为什么Python在科研界流行的原因。</p>
<p>从此，开始了Python的征程，至今也在天天写Python代码。有了一定的Ruby基础，Python学起来还是非常快的，虽然这些丰富的语言特性记不住，写的代码也不够Pythonic，为了练习先是去用Python刷题了，效果还是不错的，经常看到大牛写的代码，那叫一个牛掰，自己写了七八行，人家一两行搞定了，写的还简洁易懂，不易懂的，我是不会给他点赞的。</p>
<p>如今实验室的项目也是用Python做的，如果不是带着一门助教，平常是不会写C的。</p>
<h1 id="总结陈词">总结陈词</h1><p>过去认为是，我们是主体，语言是客体，我们选择了语言。</p>
<p>如今感觉，项目/工程是主体，语言是客体，是你参与的项目选择了语言，而不是我们选择了语言。</p>
<p>将来，也许还会在写Java，C++等等，原因请见上一条。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-06T14:30:03.000Z"><a href="/2015/05/06/Optimize-of-hexo-blog/">2015-05-06</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/06/Optimize-of-hexo-blog/">Hexo 博客优化</a></h1>
  

    </header>
    <div class="entry">
      
        
        <p>用Firebug看了一下加载速度，OMG!</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/loading-speed.JPG" alt="加载速度"></p>
<p>jquery.min.js</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-03T16:00:00.000Z"><a href="/2015/05/04/Ch5-Exercises-and-Solutions-of-TADM2E/">2015-05-04</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/04/Ch5-Exercises-and-Solutions-of-TADM2E/">算法设计手册第二版第五章课后习题解答</a></h1>
  

    </header>
    <div class="entry">
      
        
          <div id="toc" class="toc-article">
          <strong class="toc-title">文章目录</strong>
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目Wiki及参考答案"><span class="toc-number">1.</span> <span class="toc-text">题目Wiki及参考答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我的解答"><span class="toc-number">2.</span> <span class="toc-text">我的解答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历"><span class="toc-number">2.1.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6"><span class="toc-number">2.1.1.</span> <span class="toc-text">5-6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7"><span class="toc-number">2.1.2.</span> <span class="toc-text">5-7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8"><span class="toc-number">2.1.3.</span> <span class="toc-text">5-8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9"><span class="toc-number">2.1.4.</span> <span class="toc-text">5-9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10"><span class="toc-number">2.1.5.</span> <span class="toc-text">5-10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-12"><span class="toc-number">2.1.6.</span> <span class="toc-text">5-12</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-13"><span class="toc-number">2.1.7.</span> <span class="toc-text">5-13</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-14"><span class="toc-number">2.1.8.</span> <span class="toc-text">5-14</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-15"><span class="toc-number">2.1.9.</span> <span class="toc-text">5-15</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-16"><span class="toc-number">2.1.10.</span> <span class="toc-text">5-16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-17"><span class="toc-number">2.1.11.</span> <span class="toc-text">5-17</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-18"><span class="toc-number">2.1.12.</span> <span class="toc-text">5-18</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-19"><span class="toc-number">2.1.12.1.</span> <span class="toc-text">5-19</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-20"><span class="toc-number">2.1.13.</span> <span class="toc-text">5-20</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-21"><span class="toc-number">2.1.14.</span> <span class="toc-text">5-21</span></a></li></ol></li></ol></li></ol>
          </div>
        
        <blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Graphs-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Graphs-TADM2E</a></p>
<h2 id="我的解答">我的解答</h2><h3 id="遍历">遍历</h3><h4 id="5-6">5-6</h4><p>题目</p>
<p>In breadth-first and depth-first search, an undiscovered node is marked discovered when it is first encountered, and marked processed when it has been completely searched. At any given moment, several nodes might be simultaneously in the discovered state.<br>(a) Describe a graph on n vertices and a particular starting vertex v such that Θ(n) nodes are simultaneously in the discovered state during a breadth-first search starting from v.<br>(b) Describe a graph on n vertices and a particular starting vertex v such that Θ(n) nodes are simultaneously in the discovered state during a depth-first search starting from v.<br>(c) Describe a graph on n vertices and a particular starting vertex v such that at some point Θ(n) nodes remain undiscovered, while Θ(n) nodes have been processed during a depth-first search starting from v. (Note, there may also be discovered nodes.)</p>
<p>解答</p>
<p>(a) Wrost case: 所有的节点都与根节点v直接相连。<br>(b) Wrost case: 所有的节点的出度都小于等于2，即所有的点都在一条线上。<br>(c) 非连通图。</p>
<h4 id="5-7">5-7</h4><p>题目</p>
<p>Given pre-order and in-order traversals of a binary tree, is it possible to reconstruct the tree? If so, sketch an algorithm to do it. If not, give a counterexample. Repeat the problem if you are given the pre-order and post-order traversals.</p>
<p>解答</p>
<p>(a) pre-order and in-order</p>
<p>先序遍历特点：第一个节点是根节点。<br>中序遍历特点：先遍历根节点的左子树，再根节点，然后根节点的右子树。</p>
<p>算法思路：</p>
<ol>
<li>根据先序遍历序列得到root。</li>
<li>根据root和中序遍历序列得到左右子树。</li>
<li>递归建立左子树。</li>
<li>递归建立右子树。</li>
</ol>
<p>(b) pre-order and post-order</p>
<p>后序遍历特点：先遍历根节点的左子树，再根节点的右子树，然后根节点。</p>
<p>只有先、后遍历序列，无法划分左右子树，无法建立树。</p>
<h4 id="5-8">5-8</h4><p>题目</p>
<p>Present correct and efficient algorithms to convert an undirected graph G between the following graph data structures. You must give the time complexity of each algorithm, assuming n vertices and m edges.<br>(a) Convert from an adjacency matrix to adjacency lists.<br>(b) Convert from an adjacency list to an incidence matrix. An incidence matrix M has a row for each vertex and a column for each edge, such that M[i,j]=1 if vertex i is part of edge j, otherwise M[i,j]=0.<br>(c) Convert from an incidence matrix to adjacency lists.</p>
<p>解答</p>
<p>访问所有的边和点的时间复杂度：<br>邻接矩阵：O(n<sup>2</sup>)<br>邻接链表：O(n+m)</p>
<p>(a) 无向图的邻接矩阵具有对称性，不必遍历整个矩阵。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for x from 1 to n&#10;    for y from x+1 to n&#10;        if M[x][y] = 1&#10;            insert(&#38;g, x, y)</span><br></pre></td></tr></table></figure>
<p>需要花费O(n<sup>2</sup>)从邻接矩阵读数据，然后花费O(n+m)建立邻接链表。</p>
<p>(b) 关联矩阵：形成点和边的映射，矩阵大小为 <code>n·m</code>，建立关联矩阵并初始化需要O(nm)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edgesx[]    // &#36793;i&#36830;&#25509;&#30340;x&#33410;&#28857;&#10;edgesy[]    // &#36793;i&#36830;&#25509;&#30340;y&#33410;&#28857;&#65292;x&#60;y&#10;cur = -1    // &#24403;&#21069;&#36793;&#30340;&#32534;&#21495;&#10;&#10;list_2_incidence(&#38;g, IM[][]):&#10;    for x from 1 to g-&#62;nvertices&#10;        p = p-&#62;edges[x]&#10;        while p != null&#10;            y = p-&#62;y&#10;            if !recorded_edge(x, y)&#10;                recording_edge(x,y)&#10;                IM[x][cur] = 1&#10;                IM[y][cur] = 1&#10;            p = p-&#62;next&#10;&#10;recording_edge(x, y):&#10;    if (x &#62; y)&#10;        swap(x, y)&#10;    edgesx[i] = x&#10;    edgesy[i] = y&#10;    cur++&#10;&#10;recorded_edge(x, y):&#10;    if (x &#62; y)&#10;        swap(x, y)&#10;    for i from 0 to cur&#10;        if x == edges[i] &#38;&#38; y == edgesy[i] // &#23384;&#22312;&#19968;&#20010;i&#10;            return 1&#10;    return 0</span><br></pre></td></tr></table></figure>
<p>在关联矩阵中为每条边写入数据需要花费O(1)，共m条边，需要花费O(m)。从邻接链表读取数据，并检测该边是不是已经记录需要花费O(n+m<sup>2</sup>)，其中检测一条边需要O(m)。因此总的时间花费为O(nm+n+m*m) = O(nm+m<sup>2</sup>)。</p>
<p>(c) 遍历每一条边，然后插入到邻接矩阵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for j from 1 to m&#10;    x = y = -1&#10;    for i from 1 to n&#10;        if M[i][j] = 1&#10;            if x == -1, x = i&#10;            else y = i, insert(&#38;g, x, y), break</span><br></pre></td></tr></table></figure>
<p>遍历需要O(nm)，插入需要O(1)，故共需要O(nm)。</p>
<h4 id="5-9">5-9</h4><p>题目</p>
<p>Suppose an arithmetic expression is given as a tree. Each leaf is an integer and each internal node is one of the standard arithmetical operations <code>(+,−,*,/)</code>. For example, the expression <code>2+3*4+(3*4)/5</code> is represented by the tree in Figure 5.17(a).<br>Give an O(n) algorithm for evaluating such an expression, where there are n nodes in the tree.</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Figure 5.17.JPG" alt="Figure 5.17"></p>
<p>解答</p>
<p>采用递归的方式，获得左子树操作数和右子树操作数，然后做运算，每个节点都会访问一次，时间复杂度O(n)。</p>
<p>假设树节点的定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">operator</span>;</span><br><span class="line">    <span class="keyword">struct</span> node *left;</span><br><span class="line">    <span class="keyword">struct</span> node *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">calc_tree(root):</span><br><span class="line">    <span class="keyword">if</span> root-&gt;left = null and root-&gt;right = null</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        op1 = calc_tree(root-&gt;left)</span><br><span class="line">        op2 = calc_tree(root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> calc(op1, root-&gt;<span class="keyword">operator</span>, op2)  <span class="comment">// 进行基本运算</span></span><br></pre></td></tr></table></figure>
<h4 id="5-10">5-10</h4><p>题目</p>
<p>Suppose an arithmetic expression is given as a DAG (directed acyclic graph) with common subexpressions removed. Each leaf is an integer and each internal node is one of the standard arithmetical operations <code>(+,−,*,/)</code>. For example, the expression <code>2+3*4+(3*4)/5</code> is represented by the DAG in Figure (see book)(b). Give an O(n+m) algorithm for evaluating such a DAG, where there are n nodes and m edges in the DAG. Hint: modify an algorithm for the tree case to achieve the desired efficiency.</p>
<p>解答</p>
<p>为节点设置一个标记，若已算过该子树，标记设置为true。当再次访问此子树时，可直接获得该子树的结果。再次访问的次数不会超过m，时间复杂度为O(n+m)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">operator</span>;</span><br><span class="line">    <span class="keyword">int</span> flag;           <span class="comment">// 该子树的值是否已计算</span></span><br><span class="line">    <span class="keyword">struct</span> node *left;</span><br><span class="line">    <span class="keyword">struct</span> node *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">calc_tree(root):</span><br><span class="line">    <span class="keyword">if</span> root-&gt;left = null and root-&gt;right = null</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> root-&gt;left and root-&gt;right and flag = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        op1 = calc_tree(root-&gt;left)</span><br><span class="line">        op2 = calc_tree(root-&gt;right)</span><br><span class="line">        root-&gt;val = calc(op1, root-&gt;<span class="keyword">operator</span>, op2) <span class="comment">// 进行基本运算</span></span><br><span class="line">        root-&gt;flag = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span>   root-&gt;val</span><br></pre></td></tr></table></figure>
<h4 id="5-12">5-12</h4><p>题目</p>
<p>The square of a directed graph G=(V,E) is the graph G2=(V,E2) such that (u,w)∈E2 iff there exists v∈V such that (u,v)∈E and (v,w)∈E; i.e., there is a path of exactly two edges from u to w. square of a graph Give efficient algorithms for both adjacency lists and matrices.</p>
<p>解答</p>
<p>首先，必须清楚这是有向图。</p>
<ol>
<li><p>邻接矩阵</p>
<p> 这个题目的重点是找到节点v的孙子节点w，连接v与w。如果采用暴力的方法三层for循环遍历邻接矩阵，时间复杂度是O(n<sup>3</sup>)，代价还是很大的，尤其是n比较大，且图G是稀疏图。</p>
<p> 如果能有效降低for循环内的次数，虽然时间复杂度是O(n<sup>3</sup>)，但是实际上可能也不会那么高了。</p>
<p> 优化方案是为每个节点建立一个队列，那么所有队列的总长度为m（图G边的总数）。这样，遍历该节点的队列就可以得到该节点的孩子。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i from <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> j from <span class="number">1</span> to n</span><br><span class="line">        <span class="keyword">if</span> G[i,j] = <span class="number">1</span>, append(q[i], j)  <span class="comment">// 将j添加到i的队列中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i from <span class="number">1</span> to n</span><br><span class="line">    foreach j in q[i]</span><br><span class="line">        foreach k in q[j]</span><br><span class="line">            square_G[i,k] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p> 构建队列的时间复杂度为O(n<sup>2</sup>)，构建G<sup>2</sup>的外面两层循环时间复杂度为O(m)。则每个队列的平均长度为 m/n，则内层循环的时间复杂度为O(m/n)，总为O(m<sup>2</sup>/n)。从另外一个角度讲，G<sup>2</sup>的边数小于2m（你可以试着证明一下，我还不能给出准确的证明），那么<code>square_G[i,k] = 1</code>的执行次数小于2m。时间复杂度应该为O(n<sup>2</sup>+m)。</p>
</li>
<li><p>邻接链表</p>
<p> 现在回想一下，在邻接矩阵的解决方案中，使用的队列，就相当于邻接链表。那我们就省去了构建队列的时间，时间复杂度O(m)。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i from <span class="number">1</span> to n</span><br><span class="line">    foreach j in g-&gt;edges[i]</span><br><span class="line">        foreach k in g-&gt;edges[j]</span><br><span class="line">            insert_edges(square_g-&gt;edges, i, k, TRUE)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="5-13">5-13</h4><p>题目</p>
<p>A vertex cover of a graph G=(V,E) is a subset of vertices V′ such that each edge in E is incident on at least one vertex of V′.<br>(a) Give an efficient algorithm to find a minimum-size vertex cover if G is a tree.<br>(b) Let G=(V,E) be a tree such that the weight of each vertex is equal to the degree of that vertex. Give an efficient algorithm to find a minimum-weight vertex cover of G.<br>(c) Let G=(V,E) be a tree with arbitrary weights associated with the vertices. Give an efficient algorithm to find a minimum-weight vertex cover of G.</p>
<p>解答</p>
<ul>
<li><p>(a) 解决思路如下：</p>
<ol>
<li>叶节点l是不能要的，因为一个叶节点才连一条边，性价比太低了。</li>
<li>那就需要叶节点的父节点p。</li>
<li>p的父节点也就不需要了。</li>
<li><p>删除p子树，就会得到一颗新的树。重复操作，直到得到空树或只有一个节点的树。</p>
<p>怎么证明，该算法得到的就是最小的集合？<br>因为我们每次移去的子树，都尽量以一个中心节点，带走尽量多的边，那么最后得到的节点的集合，必然是最小的。</p>
<p>插图如下(以2叉树做例子)：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-13b.jpg" alt="顶点覆盖1"><br><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-13a.jpg" alt="顶点覆盖2"></p>
</li>
</ol>
</li>
<li><p>(b) 任何一条边在V’中至少有一个节点，那么V’中所有节点的度的和sum至少为m（图G的边的总数）减少V’中相邻节点的数量，就能降低sum的值。使用(a)中的方法，可以尽量降低sum的值，因为在(a)中选择的点尽量是隔代选择。另外的隔代选择方案是吧叶节点以及他们的父亲的父亲作为目标节点，得到的V’同样是尽量小的。</p>
</li>
<li><p>(c) 待定<br>  要把树作为有向图处理吗？虽然我们把树表示成带箭头的，但是树是无向图，<a href="http://en.wikipedia.org/wiki/Tree_%28graph_theory%29" target="_blank" rel="external">维基百科</a>。</p>
</li>
</ul>
<h4 id="5-14">5-14</h4><p>题目</p>
<p>A <em>vertex cover</em> of a graph G=(V,E) is a subset of vertices V′∈V such that every edge in E contains at least one vertex from V′. Delete all the leaves from any depth-first search tree of G. Must the remaining vertices form a vertex cover of G? Give a proof or a counterexample.</p>
<p>解答</p>
<p>否定。反例：<br>下图得到的DFS序列可以是[1, 3, 2]，叶节点为2,3。那么V’={1}。并不是一个顶点覆盖。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-14.JPG" alt="5-14反例"></p>
<h4 id="5-15">5-15</h4><p>题目</p>
<p>A vertex cover of a graph G=(V,E) is a subset of vertices V′∈V such that every edge in E contains at least one vertex from V′. An independent set of graph G=(V,E) is a subset of vertices V′∈V such that no edge in E contains both vertices from V′.<br>An <em>independent vertex cover</em> is a subset of vertices that is both an independent set and a vertex cover of G. Give an efficient algorithm for testing whether G contains an independent vertex cover. What classical graph problem does this reduce to?</p>
<p>解答</p>
<p>着色问题。愣是没有想到。</p>
<h4 id="5-16">5-16</h4><p>题目</p>
<p>An <em>independent set</em> of an undirected graph G=(V,E) is a set of vertices U such that no edge in E is incident on two vertices of U.</p>
<p>(a) Give an efficient algorithm to find a maximum-size independent set if G is a tree.<br>(b) Let G=(V,E) be a tree with weights associated with the vertices such that the weight of each vertex is equal to the degree of that vertex. Give an efficient algorithm to find a maximum independent set of G.<br>(c) Let G=(V,E) be a tree with arbitrary weights associated with the vertices. Give an efficient algorithm to find a maximum independent set of G.</p>
<p>解答</p>
<ul>
<li><p>(a) 基于5-15给出的答案。我们可以先把图着色，然后遍历得到不同颜色的序列，去较短的序列作为最小的独立集合。若不能着色，则不存在最小独立集合。</p>
</li>
<li><p>(b) 有以下几点需要注意：</p>
</li>
</ul>
<ol>
<li>树肯定是可以着色的。</li>
<li>着色方案是固定的：孩子与父亲是相反的颜色。</li>
<li>题目要求找到最大的独立集合。</li>
</ol>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-16-b.JPG" alt="二叉树着色"></p>
<p>先着色，进行一次遍历，将不同颜色的放入两个序列，取总度的和较大者。</p>
<p>不进行着色的处理方案:设置root颜色为0，则其子为1。递归遍历左右子树，时间复杂度为O(n)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void classify(root, color):&#10;    if color = 0 then&#10;        put root into list1&#10;    else&#10;        put root into list2&#10;    if root-&#62;left then&#10;        classify(root-&#62;left, !color)&#10;    if root-&#62;right then&#10;        classify(root-&#62;right, !color)</span><br></pre></td></tr></table></figure>
<ul>
<li>(c) 与(b)的不同仅仅是最后，取权重的和的较大者。</li>
</ul>
<h4 id="5-17">5-17</h4><p>题目</p>
<p>Consider the problem of determining whether a given undirected graph G=(V,E) contains a triangle or cycle of length 3.</p>
<p>(a) Give an O(|V|<sup>3</sup>) to find a triangle if one exists.<br>Improve your algorithm to run in time O(|V|·|E|). You may assume |V|≤|E|.<br>(b) Observe that these bounds gives you time to convert between the adjacency matrix and adjacency list representations of G.</p>
<p>解答</p>
<ul>
<li><p>(a) Brute force。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for each inode in V do&#10;    for each jnode in Adj[inode] do&#10;        for each knode in Adj[jnode] do&#10;            for each lnode in Adj[knode] do&#10;                if lnode = inode then&#10;                    return true</span><br></pre></td></tr></table></figure>
<p>  时间复杂度是O(n<sup>4</sup>)，看样子不符合题目的要求。</p>
</li>
<li><p>(b) DFS。</p>
<p>  DFS可以发现图中的环，那么当检测到环时，可以进进一步检测环的大小是否为3.采用的就是DFS一次遍历，因此时间复杂度是O(|V|+|E|)。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process_edge(v, y):&#10;    if parent[parent[x]] = y then&#10;        is_triangle = true&#10;        finish = true</span><br></pre></td></tr></table></figure>
<p>  <img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-17.JPG" alt="5-17"></p>
<p>  github仓库源码及测试数据:<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/5.11/5-17.c" target="_blank" rel="external">传送门–&gt;</a></p>
</li>
</ul>
<h4 id="5-18">5-18</h4><p>题目</p>
<p>Consider a set of movies M1, M2, … , Mk. There is a set of customers, each one of which indicates the two movies they would like to see this weekend. Movies are shown on Saturday evening and Sunday evening. Multiple movies may be screened at the same time. You must decide which movies should be televised on Saturday and which on Sunday, so that every customer gets to see the two movies they desire. Is there a schedule where each movie is shown at most once? Design an efficient algorithm to find such a schedule if one exists.</p>
<p>解答</p>
<p>问题原型：着色问题。把相邻的顶点安排在不同的时间。</p>
<p>最好的情况是符合着色问题，那么每个电影只需要放一遍。因此我们可以使用着色问题的算法解决这个问题，当着色失败时，则不存在这样最优的调度算法。</p>
<p><strong>思考</strong>：与着色问题不同的是电影可以放两次，怎样才能让总播放的次数达到最小呢？</p>
<p>电影可以放两次就相当于让一个点拥有两个颜色，在着色的过程中如果出现冲突，将此点标记为<code>double-color</code>，与他相连的还未着色的点可以是任意的颜色，那么如何才能保证全局最小呢？</p>
<h5 id="5-19">5-19</h5><p>题目</p>
<p>The <em>diameter</em> of a tree T=(V,E) is given by max u,v∈Vδ(u,v) (where δ(u,v) is the number of edges on the path from u to v). Describe an efficient algorithm to compute the diameter of a tree, and show the correctness and analyze the running time of your algorithm.</p>
<p>解答</p>
<p>最长路径。</p>
<p>称diameter最顶层的节点定义了diameter。那么对任意节点都存在两种情况：</p>
<ol>
<li>该节点定义了diameter。</li>
<li>该节点的任一子节点定义了diameter。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diameter(tree):&#10;    maxdiameter = 0&#10;    maxdepth = secdepth = -1&#10;    foreach child in children(tree) do&#10;        depth, diameter = diameter(child)&#10;        if diameter &#62; maxdiameter then&#10;            maxdiameter = diameter&#10;        if depth &#62;= maxdepth then&#10;            secdepth = maxdepth&#10;            maxdepth = depth&#10;        else if depth &#62; secdepth then&#10;            secdepth = depth&#10;    return maxdepth, max(maxdiameter, maxdepth+secdepth+2)</span><br></pre></td></tr></table></figure>
<h4 id="5-20">5-20</h4><p>题目</p>
<p>Given an undirected graph G with n vertices and m edges, and an integer k, give an O(m+n) algorithm that finds the maximum induced subgraph H of G such that each vertex in H has degree ≥k, or prove that no such graph exists. An induced subgraph F=(U,R) of a graph G=(V,E) is a subset of U of the vertices V of G, and all edges R of G such that both vertices of each edge are in U.</p>
<p>解答</p>
<p>寻找最大的导图。特性：</p>
<ol>
<li>U中所有顶点的度&gt;=K。</li>
<li>R中所有边的顶点都在U中。</li>
</ol>
<p>假设图的存储使用的是邻接链表。</p>
<p>暴力方法：<br>一次基础遍历得到符合条件的队列O(n+m)，排序O(nlogn)。<br>再次基础遍历O(n+m)看该节点的相邻节点在不在队列之中O(logn)。</p>
<p>借助DFS：</p>
<p>思想：</p>
<ul>
<li>所有的边都遍历一次，然后判断是否符合要求。</li>
<li>不使用课本提供的DFS框架，使用简化的DFS。</li>
<li>发现新顶点时，递归新的顶点。</li>
<li>若该点已被发现但还未处理，处理边(v,y)，这样确保了所有的边只处理一遍。</li>
</ul>
<p>Github：<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/5.11/5-20.c" target="_blank" rel="external">传送门</a>。</p>
<h4 id="5-21">5-21</h4><p>题目</p>
<p>Let v and w be two vertices in a directed graph G=(V,E). Design a linear-time algorithm to find the number of different shortest paths (not necessarily vertex disjoint) between v and w. Note: the edges in G are unweighted.</p>
<p>解答</p>
<p>有向图的最短段路径。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-02T13:41:34.000Z"><a href="/2015/05/02/Hexo-搭建博客参考资料列表/">2015-05-02</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/02/Hexo-搭建博客参考资料列表/">Hexo 搭建博客参考资料列表</a></h1>
  

    </header>
    <div class="entry">
      
        
          <div id="toc" class="toc-article">
          <strong class="toc-title">文章目录</strong>
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料列表"><span class="toc-number">1.</span> <span class="toc-text">参考资料列表</span></a></li></ol>
          </div>
        
        <blockquote>
<p>事总得一步一步来，记录一些参考资料。</p>
</blockquote>
<h1 id="参考资料列表">参考资料列表</h1><ol>
<li><a href="http://zespia.tw/blog/2012/10/11/hexo-debut/" target="_blank" rel="external">Hexo 主人Tommy吐槽</a></li>
<li><a href="http://yangruihan.com/2015/03/22/Windows%E4%B8%8B%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">安装 Hexo</a></li>
<li>评论系统: <a href="http://zipperary.com/2013/05/30/hexo-guide-4/" target="_blank" rel="external">参考资料1</a>，<a href="http://zhidao.baidu.com/link?url=zE0f91IjLHKzR5FEr_-aMwL6SrHSSfltLyKaTErrZ_DTcqan-xQu2IBGMo52ntBLz-vvsjO4zkPckiXBBVptbb6WR3dGu7nq_a5AFy3GKBW" target="_blank" rel="external">参考资料2</a></li>
<li><a href="http://vkki.me/2014/02/04/beautify-your-hexo/" target="_blank" rel="external">修改字体</a></li>
<li><a href="http://ju.outofmemory.cn/entry/79930" target="_blank" rel="external">网页加载慢</a></li>
<li><a href="http://www.twiceyuan.com/2015/01/12/%E4%B8%BAHexo%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">文章目录</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-01T10:39:02.000Z"><a href="/2015/05/01/Ch4-Exercises-and-Solutions-of-TADM2E/">2015-05-01</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/01/Ch4-Exercises-and-Solutions-of-TADM2E/">算法设计手册第二版第四章课后习题解答</a></h1>
  

    </header>
    <div class="entry">
      
        
          <div id="toc" class="toc-article">
          <strong class="toc-title">文章目录</strong>
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目Wiki及参考答案"><span class="toc-number">1.</span> <span class="toc-text">题目Wiki及参考答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我的解答"><span class="toc-number">2.</span> <span class="toc-text">我的解答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面试问题"><span class="toc-number">2.1.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-45"><span class="toc-number">2.1.1.</span> <span class="toc-text">4-45</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#变形及分析"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">变形及分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-46"><span class="toc-number">2.1.2.</span> <span class="toc-text">4-46</span></a></li></ol></li></ol></li></ol>
          </div>
        
        <blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Sorting-searching-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Sorting-searching-TADM2E</a></p>
<h2 id="我的解答">我的解答</h2><h3 id="面试问题">面试问题</h3><h4 id="4-45">4-45</h4><p>题目</p>
<p>Given a search string of three words, find the smallest snippet of the document that contains all three of the search words—i.e., the snippet with smallest number of words in it. You are given the index positions where these words occur in the document, such as word1: (1, 4, 5), word2: (3, 9, 10), and word3: (2, 6, 15). Each of the lists are in sorted order, as above.</p>
<p>解答</p>
<p>每个单词出现的位置列表都是有序的，将它们看做是队列。设定<code>min_len</code>保存当前最短的片段的长度，初始化为-1.算法步骤如下：</p>
<ol>
<li>若各队列不空，将各队列最小元素出队,组成三元组</li>
<li>得三元组<code>(a1, a2, a3)</code></li>
<li>求三元组中的最大值<code>max</code>，与最小值<code>min</code>，则当前片段长度<code>len = max-min+1</code></li>
<li>如果<code>min_len</code>为-1或<code>min_len</code>大于<code>len</code>，<code>min_len = len</code>，保存三元组.</li>
<li>删除三元组中最小者<code>min</code>，若<code>min</code>对应队列不空，取新元素加入到三元组，执行2，若空，退出循环。</li>
</ol>
<h5 id="变形及分析">变形及分析</h5><p>变形</p>
<p>假设输入数据不是3个单词的出现位置，而直接是一个字符串数组，那么如何找到满足要求的最小片段？</p>
<p>分析</p>
<p>设<code>cur</code>为访问数组的当前位置，3个变量<code>l1, l2, l3</code>，代表<code>cur</code>前面离<code>cur</code>最近的3个单词(w1, w2, w3)的位置。若cur上的单词为3个单词之一，不妨设为w3，则计算w3与w1,w2的距离即<code>cur-l1+1</code>和<code>cur-l2+1</code>，取小者为<code>min</code>，另<code>min</code>与<code>min_len</code>比较，若min更小，保存<code>min</code>，及当前3个单词的位置。当遍历数组结束时，最后的<code>min_len</code>与保存的3元素的位置即满足要求的最小片段。</p>
<h4 id="4-46">4-46</h4><p>题目</p>
<p>You are given 12 coins. One of them is heavier or lighter than the rest. Identify this coin in just three weighings.<br>Note - weighings are with a balance, where you can have a greater than, equal to, or less than result. You can’t do this with a digital scale.</p>
<p>解答</p>
<p>答案Wiki之中给出的3步解决的办法，但是我想不到这个解决方案。下面讨论一下 <strong>二分搜索</strong>在这里的应用。</p>
<p>题目是不知道是偏重还是偏轻的，如果知道偏重或偏轻，用二分搜索可3步解决。这种情况下，可以使用4步二分搜索。</p>
<ol>
<li>分为3堆，各4个硬币，记为a, b, c.</li>
<li>比较(a, b) 和 (a, c). a, b, c三者中必有一个是偏大或偏小，从这两次比较重可得谁偏大或偏小。</li>
<li>假设得到的是a偏大，再将a进行两次二分搜索，即可的偏大的那枚硬币。</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-01T09:02:53.000Z"><a href="/2015/05/01/完善博客待办列表/">2015-05-01</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/01/完善博客待办列表/">完善博客待办列表</a></h1>
  

    </header>
    <div class="entry">
      
        
          <div id="toc" class="toc-article">
          <strong class="toc-title">文章目录</strong>
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#原则"><span class="toc-number">1.</span> <span class="toc-text">原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#待办列表"><span class="toc-number">2.</span> <span class="toc-text">待办列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完成列表"><span class="toc-number">3.</span> <span class="toc-text">完成列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不可完成"><span class="toc-number">4.</span> <span class="toc-text">不可完成</span></a></li></ol>
          </div>
        
        <blockquote>
<p>事情总要一步一步来，慢慢完善博客。</p>
</blockquote>
<h3 id="原则">原则</h3><ol>
<li>一天最多完成一条</li>
<li>可以多天完成一条，但不得超过3天</li>
<li>从待办列表任选一条，不必按顺序</li>
</ol>
<h3 id="待办列表">待办列表</h3><ol>
<li>主页不许要显示全文</li>
<li>Google搜索无结果</li>
</ol>
<h3 id="完成列表">完成列表</h3><ol>
<li>为博客添加评论系统</li>
<li>修改字体（大小、样式）</li>
<li>改变404</li>
<li>优化加载速度</li>
<li>取消分享: <code>layout\...\article.ejs</code>删除`&lt;%- partial(‘post/share’) %&gt;</li>
<li>去掉页面中众多的<code>box_shadow</code>效果</li>
</ol>
<h3 id="不可完成">不可完成</h3><ol>
<li>修改多说，去掉不必要的账号登陆：人人，豆瓣，开心(没有提供接口)</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-01T08:47:40.000Z"><a href="/2015/05/01/Github-Pages-Hexo部署总结/">2015-05-01</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/01/Github-Pages-Hexo部署总结/">Github Pages + Hexo部署总结</a></h1>
  

    </header>
    <div class="entry">
      
        
          <div id="toc" class="toc-article">
          <strong class="toc-title">文章目录</strong>
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#值得思考的事情"><span class="toc-number">1.</span> <span class="toc-text">值得思考的事情</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">2.</span> <span class="toc-text">参考资料</span></a></li></ol>
          </div>
        
        <h1 id="值得思考的事情">值得思考的事情</h1><ol>
<li>为什么要搭博客？</li>
<li>你能坚持写作吗？</li>
</ol>
<p>如果不能回答第一个问题，或者也不能坚持，还是放弃吧，因为搭博客很烦人，如果不能坚持，大博客就变成浪费时间了，不如写写代码。</p>
<p>我现在搭这个博客，是为了把 <em>The Algorithm Design Manual</em> 上的部分习题记录下来。找一件事做，才有东西可写，才能坚持下去。</p>
<h1 id="参考资料">参考资料</h1><p>参考资料众多，我再写一篇就是，重复造轮子了。</p>
<p>参考资料：<a href="http://yangruihan.com/" target="_blank" rel="external">http://yangruihan.com/</a> 。他采用了Github Pages + Hexo，风格个人比较喜欢，之前也用jekyII，Octopress搭过，目前Hexo看起来更舒服，并且过程相对简单。</p>
<p>安装时有以下建议：</p>
<ol>
<li>安装Node.js后，更改为国内源，不然安装Hexo慢…<br> 参考：<a href="http://yijiebuyi.com/blog/b12eac891cdc5f0dff127ae18dc386d4.html" target="_blank" rel="external">http://yijiebuyi.com/blog/b12eac891cdc5f0dff127ae18dc386d4.html</a></li>
<li>yangruihan提到的Node.js安装失败，重启主机即可。</li>
<li>部署失败可参考文件<code>——config.yml</code>中所提供的链接：<a href="http://hexo.io/docs/deployment.html。" target="_blank" rel="external">http://hexo.io/docs/deployment.html。</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shitaibin.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/教程/">教程</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Github-Pages/">Github Pages</a><small>1</small></li>
  
    <li><a href="/tags/Hexo/">Hexo</a><small>4</small></li>
  
    <li><a href="/tags/Python试错/">Python试错</a><small>1</small></li>
  
    <li><a href="/tags/TADM/">TADM</a><small>2</small></li>
  
    <li><a href="/tags/blog/">blog</a><small>1</small></li>
  
    <li><a href="/tags/图论/">图论</a><small>1</small></li>
  
    <li><a href="/tags/待办/">待办</a><small>1</small></li>
  
    <li><a href="/tags/招聘/">招聘</a><small>1</small></li>
  
    <li><a href="/tags/排序/">排序</a><small>1</small></li>
  
    <li><a href="/tags/搜索/">搜索</a><small>2</small></li>
  
    <li><a href="/tags/编程语言/">编程语言</a><small>1</small></li>
  
    <li><a href="/tags/翻译/">翻译</a><small>1</small></li>
  
    <li><a href="/tags/面试/">面试</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 James Shi
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>